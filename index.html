<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/23/hello-world/" class="article-date">
  <time datetime="2017-12-23T14:58:42.000Z" itemprop="datePublished">2017-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/23/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/23/hello-world/" data-id="cjbjiv6u40006rwdlftunzllz" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-抓包工具介绍" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/23/抓包工具介绍/" class="article-date">
  <time datetime="2017-12-23T09:19:58.000Z" itemprop="datePublished">2017-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/23/抓包工具介绍/">抓包工具介绍</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="抓包工具介绍"><a href="#抓包工具介绍" class="headerlink" title="抓包工具介绍"></a>抓包工具介绍</h1><p>[TOC]</p>
<h2 id="whistle"><a href="#whistle" class="headerlink" title="whistle"></a>whistle</h2><ul>
<li><a href="https://github.com/avwo/whistle" target="_blank" rel="noopener">Github地址</a></li>
<li><a href="https://avwo.github.io/whistle/" target="_blank" rel="noopener">具体说明文档</a></li>
<li>whistle是一款用Node实现的跨平台的Web调试代理工具，支持查看修改http(s)、Websocket连接的请求和响应内容</li>
</ul>
<blockquote>
<p>最新版本的whistle支持三种等价的命令whistle、w2、wproxy</p>
</blockquote>
<h3 id="启动whistle"><a href="#启动whistle" class="headerlink" title="启动whistle"></a>启动whistle</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ w2 start</span><br></pre></td></tr></table></figure>
<h3 id="重启whsitle"><a href="#重启whsitle" class="headerlink" title="重启whsitle"></a>重启whsitle</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ w2 restart</span><br></pre></td></tr></table></figure>
<h3 id="停止whistle"><a href="#停止whistle" class="headerlink" title="停止whistle"></a>停止whistle</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ w2 stop</span><br></pre></td></tr></table></figure>
<h3 id="调试模式启动whistle-主要用于查看whistle的异常及插件开发"><a href="#调试模式启动whistle-主要用于查看whistle的异常及插件开发" class="headerlink" title="调试模式启动whistle(主要用于查看whistle的异常及插件开发)"></a>调试模式启动whistle(主要用于查看whistle的异常及插件开发)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ w2 run</span><br></pre></td></tr></table></figure>
<h3 id="更新whistle"><a href="#更新whistle" class="headerlink" title="更新whistle"></a>更新whistle</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 以下命令都可以更新whistle</span><br><span class="line">$ npm install -g whistle</span><br><span class="line"># or</span><br><span class="line">$ npm update -g whistle</span><br><span class="line"># or</span><br><span class="line">$ npm install -g whistle --registry=https://registry.npm.taobao.org</span><br><span class="line"># or</span><br><span class="line">$ npm update -g whistle --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<ul>
<li>更新成功后，重启 whistle</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ w2 restart</span><br></pre></td></tr></table></figure>
<h3 id="whistle界面操作快捷键"><a href="#whistle界面操作快捷键" class="headerlink" title="whistle界面操作快捷键"></a>whistle界面操作快捷键</h3><ul>
<li>清空请求列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + X(Mac用Command + X):</span><br></pre></td></tr></table></figure>
<ul>
<li>如果是焦点在下面的过滤输入框，可以清空输入框的内容</li>
<li>如果焦点在Network的其它地方，可以删除选中的请求项</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + D(Mac用Command + D):</span><br></pre></td></tr></table></figure>
<h2 id="Charles"><a href="#Charles" class="headerlink" title="Charles"></a>Charles</h2><ul>
<li><a href="https://www.charlesproxy.com/" target="_blank" rel="noopener">官方网站</a></li>
<li>是一个HTTP代理服务器,HTTP监视器,反转代理服务器，当浏览器连接Charles的代理访问互联网时，Charles可以监控浏览器发送和接收的所有数据。它允许一个开发者查看所有连接互联网的HTTP通信，这些包括request, response和HTTP headers （包含cookies与caching信息）</li>
</ul>
<h3 id="Charles主要功能"><a href="#Charles主要功能" class="headerlink" title="Charles主要功能"></a>Charles主要功能</h3><ol>
<li>支持SSL代理。可以截取分析SSL的请求。</li>
<li>支持流量控制。可以模拟慢速网络以及等待时间（latency）较长的请求。</li>
<li>支持AJAX调试。可以自动将json或xml数据格式化，方便查看。</li>
<li>支持AMF调试。可以将Flash Remoting 或 Flex Remoting信息格式化，方便查看。</li>
<li>支持重发网络请求，方便后端调试。</li>
<li>支持修改网络请求参数。</li>
<li>支持网络请求的截获并动态修改。</li>
<li>检查HTML，CSS和RSS内容是否符合W3C标准。</li>
</ol>
<h3 id="代理基本设置"><a href="#代理基本设置" class="headerlink" title="代理基本设置"></a>代理基本设置</h3><p><strong>调出端口设置页面</strong></p>
<blockquote>
<p>菜单栏操作 Proxy-&gt;Proxy Settings…</p>
</blockquote>
<p><strong>设置端口</strong></p>
<blockquote>
<p>选中Proxies面板-&gt;HTTP Proxy 下的Port: 后填入 8888 -&gt; 点击OK完成</p>
</blockquote>
<p><strong>设置手机代理</strong></p>
<blockquote>
<p>打开WLAN设置-&gt;进入链接的WiFi的设置。<br>代理处选择手动-&gt;主机名设置为安装Charles的主机的IP-&gt;端口输入Charles设置的端口号-&gt;点击确定完成（苹果手机返回就行）<br>主机IP，在终端打 <code>ifconfig</code> ，找到类似 <code>192.168.199.248</code></p>
</blockquote>
<h3 id="抓取https请求设置"><a href="#抓取https请求设置" class="headerlink" title="抓取https请求设置"></a>抓取https请求设置</h3><p><strong>手机安装证书</strong></p>
<blockquote>
<p>菜单栏操作 Help-&gt;SSL Proxing-&gt;Install Charles Root Certificate on a Mobile Device or Remote Browser<br>弹出下文中的资料，在手机浏览器中输入，<code>chls.pro/ssl</code>，安装相应证书</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Configure your device to use Charles as its HTTP proxy on 192.168.199.248:1208, then browse to chls.pro/ssl to download and install the certificate.</span><br></pre></td></tr></table></figure>
<p><strong>Charles设置代理https</strong></p>
<blockquote>
<p>菜单栏操作 Proxy-&gt;SSL Proxying Settings…<br>开启SSL代理-&gt;输入要抓取https接口的域名-&gt;OK</p>
</blockquote>
<p><strong>如果还抓取不到https</strong></p>
<ul>
<li>【Proxy】=&gt;【SSL Proxying Settings】</li>
<li>勾选 <code>Enable SSL Proxying</code></li>
<li>Host 表示你要抓取的 <code>ip</code> 地址或是链接，Port 填写 <code>443</code> 即可</li>
<li><em>注：Port不填写443后续还是抓不到，这个坑我踩了</em></li>
</ul>
<p><strong>如果还抓取不到</strong></p>
<ul>
<li>检查你的手机是不是 iOS 10.3 及以上版本，如果是的话的还需要进入 <code>手机设置-&gt;通用-&gt;关于本机-&gt;证书信任设置</code>，如下图，证书选择信任就可以了</li>
</ul>
<h3 id="分析抓取的数据包"><a href="#分析抓取的数据包" class="headerlink" title="分析抓取的数据包"></a>分析抓取的数据包</h3><p><strong>Charles 主要提供两种查看封包的视图</strong></p>
<ul>
<li>Structure 视图将网络请求按访问的域名分类</li>
<li>Sequence 视图将网络请求按访问的时间排序</li>
</ul>
<h3 id="Charles弱网模拟"><a href="#Charles弱网模拟" class="headerlink" title="Charles弱网模拟"></a>Charles弱网模拟</h3><ul>
<li>菜单中选择【Proxy】—&gt;【Throttle Settings..】-à激活【Enable Throttling</li>
<li>在Throttle Configuration设置弱网的参数</li>
<li><a href="https://wenku.baidu.com/view/fbc19fb431126edb6e1a1055.html" target="_blank" rel="noopener">2G3G4G频率分配和网络制式</a></li>
</ul>
<h3 id="内容替换"><a href="#内容替换" class="headerlink" title="内容替换"></a>内容替换</h3><ul>
<li>选中文件，选择菜单【Proxy】—&gt;【Tools】—&gt;【Map Local Settings】—&gt;【add】</li>
<li>选中文件，右键选择【Edit Mapping】或者</li>
<li>然后设置自己要替换的文件就可以了</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/23/抓包工具介绍/" data-id="cjbjiv6uc000brwdlfo2y9sej" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Homebrew-macOS缺失的软件包管理器（简称brew）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/11/Homebrew-macOS缺失的软件包管理器（简称brew）/" class="article-date">
  <time datetime="2017-12-11T12:04:17.000Z" itemprop="datePublished">2017-12-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/11/Homebrew-macOS缺失的软件包管理器（简称brew）/">Homebrew-macOS缺失的软件包管理器（简称brew）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Homebrew-macOS缺失的软件包管理器（简称brew）"><a href="#Homebrew-macOS缺失的软件包管理器（简称brew）" class="headerlink" title="Homebrew-macOS缺失的软件包管理器（简称brew）"></a>Homebrew-macOS缺失的软件包管理器（简称brew）</h1><p>[TOC]</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>brew又叫Homebrew，是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件，只需要一个简单的命令，非常方便</li>
</ul>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ul>
<li>在真正了解软件包管理工具之前，一直是出于混乱状态，用到什么下载什么，来源也不尽相同，有来自git的、有来自安装包下载的、还有来自百度的等等，记得最让我难忘的就是关于MySQL数据库的学习，我下载了好多版本不同路径不同来源的数据库，后来导致终端软件管理出现了混乱，配置文件也是一塌糊涂；</li>
<li>这次是为了 小程序Trace导出工具 安装ADB，最好的方式是安装brew，但是安装的过程中各种出错，最好的方式就是重新做系统然后进行软件包管理</li>
<li>也就引起了这次深入研究</li>
</ul>
<h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a><a href="https://brew.sh/" target="_blank" rel="noopener">官网</a></h2><h2 id="安装Homebrew"><a href="#安装Homebrew" class="headerlink" title="安装Homebrew"></a>安装Homebrew</h2><p><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></p>
<h2 id="安装目录介绍"><a href="#安装目录介绍" class="headerlink" title="安装目录介绍"></a>安装目录介绍</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/local</span><br><span class="line">$ find Cellar</span><br><span class="line">Cellar/wget/1.16.1</span><br><span class="line">Cellar/wget/1.16.1/bin/wget</span><br><span class="line">Cellar/wget/1.16.1/share/man/man1/wget.1</span><br><span class="line"></span><br><span class="line">$ ls -l bin</span><br><span class="line">bin/wget -&gt; ../Cellar/wget/1.16.1/bin/wget</span><br></pre></td></tr></table></figure>
<ul>
<li>Homebrew会将软件包安装到独立目录，并将其文件软链接至/usr/local</li>
<li>Homebrew不会将文件安装到它本身目录之外，所以您可将Homebrew安装到任意位置</li>
</ul>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="查看brew版本"><a href="#查看brew版本" class="headerlink" title="查看brew版本"></a>查看brew版本</h3><p><code>brew -v</code></p>
<h3 id="安装公式"><a href="#安装公式" class="headerlink" title="安装公式"></a>安装公式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install formula</span><br><span class="line">例子：brew install wget</span><br></pre></td></tr></table></figure>
<h3 id="写在公式"><a href="#写在公式" class="headerlink" title="写在公式"></a>写在公式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew uninstall formula</span><br><span class="line">例子：brew uninstall wget</span><br></pre></td></tr></table></figure>
<h3 id="搜索公式"><a href="#搜索公式" class="headerlink" title="搜索公式"></a>搜索公式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew search /formula/</span><br><span class="line">例子：brew search /wge*/</span><br><span class="line">*表示模糊搜索</span><br></pre></td></tr></table></figure>
<h3 id="查看已安装软件"><a href="#查看已安装软件" class="headerlink" title="查看已安装软件"></a>查看已安装软件</h3><p><code>brew list</code></p>
<h3 id="更新brew"><a href="#更新brew" class="headerlink" title="更新brew"></a>更新brew</h3><p><code>brew update</code></p>
<h3 id="用浏览器打开brew官方网站"><a href="#用浏览器打开brew官方网站" class="headerlink" title="用浏览器打开brew官方网站"></a>用浏览器打开brew官方网站</h3><p><code>brew home</code></p>
<h3 id="显示软件信息"><a href="#显示软件信息" class="headerlink" title="显示软件信息"></a>显示软件信息</h3><p><code>brew info</code></p>
<h3 id="显示包依赖"><a href="#显示包依赖" class="headerlink" title="显示包依赖"></a>显示包依赖</h3><p><code>brew deps</code></p>
<h3 id="其他帮助信息"><a href="#其他帮助信息" class="headerlink" title="其他帮助信息"></a>其他帮助信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Example usage:</span><br><span class="line">  brew search [TEXT|/REGEX/]</span><br><span class="line">  brew (info|home|options) [FORMULA...]</span><br><span class="line">  brew install FORMULA...</span><br><span class="line">  brew update</span><br><span class="line">  brew upgrade [FORMULA...]</span><br><span class="line">  brew uninstall FORMULA...</span><br><span class="line">  brew list [FORMULA...]</span><br><span class="line"></span><br><span class="line">Troubleshooting:</span><br><span class="line">  brew config</span><br><span class="line">  brew doctor</span><br><span class="line">  brew install -vd FORMULA</span><br><span class="line"></span><br><span class="line">Developers:</span><br><span class="line">  brew create [URL [--no-fetch]]</span><br><span class="line">  brew edit [FORMULA...]</span><br><span class="line">  https://docs.brew.sh/Formula-Cookbook.html</span><br><span class="line"></span><br><span class="line">Further help:</span><br><span class="line">  man brew</span><br><span class="line">  brew help [COMMAND]</span><br><span class="line">  brew home</span><br></pre></td></tr></table></figure>
<h2 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h2><ul>
<li>包管理器或包管理系统是一系列软件工具的集合, 这些软件工具用和电脑操作系统一致的方式, 使应用的安装, 升级, 配置和删除软件包的过程自动化, 它通常维护一个数据库软件的依赖和版本信息, 防止软件不匹配和无法跟踪.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/11/Homebrew-macOS缺失的软件包管理器（简称brew）/" data-id="cjbjiv6ty0001rwdlmf4amwd2" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SEO从理论到实践" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/07/SEO从理论到实践/" class="article-date">
  <time datetime="2017-12-06T21:30:50.000Z" itemprop="datePublished">2017-12-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/07/SEO从理论到实践/">SEO从理论到实践</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SEO从理论到实践"><a href="#SEO从理论到实践" class="headerlink" title="SEO从理论到实践"></a>SEO从理论到实践</h1><ol>
<li>明白seo是什么</li>
<li>知道怎么做</li>
</ol>
<p>[TOC]</p>
<h2 id="什么是SEO？"><a href="#什么是SEO？" class="headerlink" title="什么是SEO？"></a>什么是SEO？</h2><p>提高网站浏览量而做的优化手段</p>
<p><strong>目的：</strong></p>
<ol>
<li>如何快速提高网站的权重及浏览量</li>
<li>有效方式，专业监测网站的浏览量</li>
</ol>
<h2 id="SEO和SEM的区别"><a href="#SEO和SEM的区别" class="headerlink" title="SEO和SEM的区别"></a>SEO和SEM的区别</h2><ul>
<li>SEO（Search Engine Optimization搜索引擎优化）：以免费的方式提高排名</li>
<li>SEM（Search Engine Marketing搜索引擎营销）：已付费的方式提高排名</li>
</ul>
<h2 id="SEO和SEM对比"><a href="#SEO和SEM对比" class="headerlink" title="SEO和SEM对比"></a>SEO和SEM对比</h2><ol>
<li>SEM高投入；SEO低投入</li>
<li>SEM短，效益快；SEO长期投入，增长慢</li>
<li>新广告法颁布之后SEM广告位减少、竞争压力大</li>
</ol>
<h2 id="IP-PV-UV"><a href="#IP-PV-UV" class="headerlink" title="IP PV UV"></a>IP PV UV</h2><ol>
<li>IP：独立IP访问的用户（00:00-24:00内相同IP地址之被计算一次）</li>
<li>PV：页面浏览量或点击量（页面浏览量或点击量，用户每次刷新即被计算一次）</li>
<li>UV：独立访客数（访问您网站的一台电脑客户端为一个访客。00:00-24:00内相同的客户端只被计算一次。）</li>
</ol>
<h2 id="搜索引擎市场份额"><a href="#搜索引擎市场份额" class="headerlink" title="搜索引擎市场份额"></a>搜索引擎市场份额</h2><p><a href="http://gs.statcounter.com/search-engine-market-share" target="_blank" rel="noopener">全球搜索引擎市场份额</a><br><a href="http://gs.statcounter.com/search-engine-market-share/all/china" target="_blank" rel="noopener">中国搜索引擎市场份额</a></p>
<h2 id="SEO排名机制"><a href="#SEO排名机制" class="headerlink" title="SEO排名机制"></a>SEO排名机制</h2><ol>
<li>搜索引擎蜘蛛（有一个非常大的数据库支撑，把抓取到的网站快照保存进行分类存储）</li>
<li>权重（这个主要看搜索引擎的相关算法和排名规则）</li>
</ol>
<h2 id="搜索引擎提交入口"><a href="#搜索引擎提交入口" class="headerlink" title="搜索引擎提交入口"></a>搜索引擎提交入口</h2><ol>
<li>百度搜索网站登录口</li>
<li>Google网站登录口</li>
<li>360搜索引擎登录入口</li>
<li>搜狗网站收录提交入口</li>
<li>必应网站提交登录入口</li>
</ol>
<h2 id="SEO优化最重要的三要素"><a href="#SEO优化最重要的三要素" class="headerlink" title="SEO优化最重要的三要素"></a>SEO优化最重要的三要素</h2><ol>
<li>标题</li>
<li>关键字</li>
<li>描述</li>
</ol>
<h2 id="提升SEO的方法"><a href="#提升SEO的方法" class="headerlink" title="提升SEO的方法"></a>提升SEO的方法</h2><h3 id="外链（友情链接）"><a href="#外链（友情链接）" class="headerlink" title="外链（友情链接）"></a>外链（友情链接）</h3><ol>
<li>外链是指网站与网站之间的链接向导</li>
<li>外链是提升权重的方式（和权重高的网站进行外链可以提升自己的权重）</li>
<li>互联网是链接与链接实现的一条网络</li>
</ol>
<h4 id="友情链接交换注意项"><a href="#友情链接交换注意项" class="headerlink" title="友情链接交换注意项"></a>友情链接交换注意项</h4><ol>
<li>和内容相近的网站交换（链接网站之间内容不相关，会导致搜索引擎拒绝收录相关信息）</li>
<li>链接交换形式多样<ol>
<li>单向链接：别人指向我或者我指向别人，而对方不指过来（好处：搜索引擎进来不再出去，使得自身权重提高）</li>
<li>双向链接：网站与网站之间互相交换链接（网站之间互相导流，共同进步共同提升）</li>
<li>单向直链（别人用浏览量低的网站指向我们，我们用好的浏览量网站指向对方，这也导致了单向链接；属于不正常手段）</li>
</ol>
</li>
<li>灌水式外链：到各大论坛、博客等等发布链接的网站，发布自己的网站，为自己导流（比如：百度论坛无法发送链接、即使发了也被屏蔽掉）</li>
</ol>
<h3 id="内链"><a href="#内链" class="headerlink" title="内链"></a>内链</h3><ul>
<li>外链在SEO中是皇上，内链就是皇后</li>
</ul>
<ol>
<li>提升网站内部页面抓取率</li>
<li>优化本站、提高流量</li>
</ol>
<h3 id="内容质量"><a href="#内容质量" class="headerlink" title="内容质量"></a>内容质量</h3><ol>
<li>更新（停止更新，搜索引擎只会保存之前的快照）</li>
<li>质量（质量低，搜索引擎会拒绝收录）</li>
<li>原创（抄袭、更改、使看起来像原创，可以在短期有效；随着搜索引擎算法的提升，伪原创效果越来越低）</li>
<li>关键字密度（2%-8%）（搜索引擎一般会抓取文章2%-8%的内容作为关键字）</li>
</ol>
<h3 id="SEO具体分类：白帽和黑帽"><a href="#SEO具体分类：白帽和黑帽" class="headerlink" title="SEO具体分类：白帽和黑帽"></a>SEO具体分类：白帽和黑帽</h3><p><strong>黑帽和沙盒</strong></p>
<ol>
<li>购买外链（搜索引擎会检测如果网站具有大量的外部单项链接，会对网站进行审查，甚至会导致打压，降权重）</li>
<li>垃圾站（和色情、赌博等相关网站，进行外链交换；导致的后果就是网站会被关进沙盒，类似小黑屋，在沙盒期内，表现不好会导致终身屏蔽）</li>
<li>黑客行为（通过非法技术手段，在对方网站添加外链的行为，比如添加隐藏的外部链接，对攻击的网站是致命的）</li>
</ol>
<h3 id="话术设置"><a href="#话术设置" class="headerlink" title="话术设置"></a>话术设置</h3><ul>
<li>是指网站关键字和描述所包含的信息量是否简洁丰富，好的话术可以给网站带来可观的浏览</li>
<li>目前百度只设置了标题和描述，话术要优质</li>
</ul>
<p><strong>例子</strong></p>
<p>原标题：前端开发，如何才能高薪就业<br>修改话术后：一个菜鸟前端的百万年薪之路</p>
<h3 id="关键词的挖掘"><a href="#关键词的挖掘" class="headerlink" title="关键词的挖掘"></a>关键词的挖掘</h3><ol>
<li>头脑风暴（专业的SEO部门，每天都要围绕在特定方向进行讨论）</li>
<li>利用搜索引擎相关搜索（搜索我们的关键字，模仿排在前面网站的关键字；或者参考相关搜索，相关搜索罗列的是被用户搜索体量大的关键字）</li>
<li>工具（百度指数，根据用户需求来设置关键字）</li>
<li>长尾关键字（是指那些热词之后的比较热门的关键词，热词一般都有大量的人使用，往往效果不如长尾关键词；或者叫垂直关键词，比如：热门关键词是“内衣”，长尾词使用“男士内衣”、“女士内衣”）</li>
</ol>
<h3 id="域名和服务器的选择"><a href="#域名和服务器的选择" class="headerlink" title="域名和服务器的选择"></a>域名和服务器的选择</h3><h4 id="域名的选择"><a href="#域名的选择" class="headerlink" title="域名的选择"></a>域名的选择</h4><ol>
<li><a href="https://baike.baidu.com/item/%E9%A1%B6%E7%BA%A7%E5%9F%9F%E5%90%8D/2152551?fr=aladdin#4" target="_blank" rel="noopener">后缀选择（.com商业组织和公司等、.top顶级的商业公司和个人、.org非盈利的组织）</a></li>
<li>短域名（容易记忆，百度：众里寻他千百度）</li>
<li>域名语义</li>
<li>域名的使用历史查询</li>
</ol>
<h4 id="服务器的选择"><a href="#服务器的选择" class="headerlink" title="服务器的选择"></a>服务器的选择</h4><ol>
<li>响应速度快（3秒定律）</li>
<li>稳定</li>
</ol>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><ol>
<li>代码去冗余（减少冗余代码、代码精简化、模块化）</li>
<li>自动化（工具：grunt、gulp、webpack、tinyPNG…）</li>
<li>语义化（h、p、a…）</li>
</ol>
<h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><ol>
<li>200（2开头的表示网页响应成功）</li>
<li>300（302、304重定向；更换域名的时候可以保证网站浏览量）</li>
<li>404（网页不存在）</li>
<li>500（5、6开头的表示服务器错误）</li>
</ol>
<h3 id="站群推广"><a href="#站群推广" class="headerlink" title="站群推广"></a>站群推广</h3><ol>
<li>淘宝客（购买链接手段，已经渐渐的衰退）</li>
<li>镜像网站（网站复制多份，相互链接；缺点：导致内部竞争效果，甚至会导致反效果，比如：QQ和微信）</li>
<li>站群模式（制作内容相近的网站，相关链接，相互提升，进行导流）</li>
</ol>
<h3 id="其他手段"><a href="#其他手段" class="headerlink" title="其他手段"></a>其他手段</h3><ol>
<li>提升用户体验（易用性、UI优化等）</li>
<li>内容形式多样（视频、奇思妙想、好的互动游戏）</li>
<li>代码属性的优化（alt描述、title标题、Logo等）</li>
<li>相关搜索引擎产品协助（工具：百度文库、问答、百度新闻-好的新闻内容会被百度抓取到百度新闻首页、百度贴吧灌水-目前被屏蔽了、百度知道等百度先关产品或其他产品、最重要的百度百科）</li>
</ol>
<h3 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h3><ol>
<li>每个搜索引擎的总体抓取量</li>
<li>记录搜索引擎蜘蛛的不重复抓取量</li>
<li>每个目录、每个搜索引擎的抓取量</li>
<li>统计搜索引擎抓取的状态码</li>
<li>统计搜索引擎抓取的次数、时间</li>
</ol>
<h3 id="搜索引擎工具"><a href="#搜索引擎工具" class="headerlink" title="搜索引擎工具"></a>搜索引擎工具</h3><ol>
<li>推广工具（购买SEM有专业的SEM工具、百度推广-国内、谷歌统计-国际）</li>
<li>百度指数（给我们提供一些好的关键词）</li>
</ol>
<h4 id="其他专业工具"><a href="#其他专业工具" class="headerlink" title="其他专业工具"></a>其他专业工具</h4><ol>
<li>CNZZ</li>
<li>爱站网、站长工具</li>
</ol>
<h3 id="SEO多领域化"><a href="#SEO多领域化" class="headerlink" title="SEO多领域化"></a>SEO多领域化</h3><ul>
<li>多年来，搜索引擎对SEO进行了打压，因为搜索引擎要靠SEM进行盈利</li>
</ul>
<ol>
<li>社交媒体SEO优化（直播、喊麦、技术视频、教学视频、博客，通过相应手段吸引流量）</li>
<li>电商SEO优化（淘宝内部推广：有的店不是皇冠依然能够被搜索到就是做了电商相关的SEO优化）</li>
<li>新媒体、微博和微信营销</li>
<li>手机和PC网站如何同时更新</li>
</ol>
<h2 id="搜索引擎其他信息"><a href="#搜索引擎其他信息" class="headerlink" title="搜索引擎其他信息"></a>搜索引擎其他信息</h2><ol>
<li>搜索引擎的进化史</li>
<li>SEO如何盈利（网盟及广告）</li>
<li>从“魏则西”事件谈搜索引擎</li>
<li>SEO的现状及生存环境</li>
<li>工具书及论坛（SEO实战密码、seoWhy）</li>
</ol>
<h2 id="合理推广，拒绝恶意营销，眼光要放长远，不能no-zuo-no-die"><a href="#合理推广，拒绝恶意营销，眼光要放长远，不能no-zuo-no-die" class="headerlink" title="合理推广，拒绝恶意营销，眼光要放长远，不能no zuo no die"></a>合理推广，拒绝恶意营销，眼光要放长远，不能no zuo no die</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/07/SEO从理论到实践/" data-id="cjbjiv6u10003rwdllr6495ty" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-音标学习记录-国际音标" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/06/音标学习记录-国际音标/" class="article-date">
  <time datetime="2017-12-06T15:42:43.000Z" itemprop="datePublished">2017-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/06/音标学习记录-国际音标/">音标学习记录-国际音标</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="音标学习记录-国际音标"><a href="#音标学习记录-国际音标" class="headerlink" title="音标学习记录-国际音标"></a>音标学习记录-国际音标</h1><p>[TOC]</p>
<h2 id="新东方老师：格格老师"><a href="#新东方老师：格格老师" class="headerlink" title="新东方老师：格格老师"></a>新东方老师：格格老师</h2><h2 id="音标分类"><a href="#音标分类" class="headerlink" title="音标分类"></a>音标分类</h2><ol>
<li>国际音标：IPA</li>
<li>美式音标：K.K.</li>
</ol>
<h2 id="IPA-and-K-K-的区别"><a href="#IPA-and-K-K-的区别" class="headerlink" title="IPA and K.K.的区别"></a>IPA and K.K.的区别</h2><ol>
<li>个数不相同，音标分为元音（20个）和辅音（28个）</li>
<li>区别在于元音上略有不同，辅音上没有区别</li>
</ol>
<h2 id="声调符号"><a href="#声调符号" class="headerlink" title="声调符号"></a>声调符号</h2><ol>
<li>第一声，（阴平，或平调，ˉ（—），调值55（高平˥˥）</li>
<li>第二声，（阳平，或升调，ˊ（/），调值35（高升˧˥）</li>
<li>第三声，（上声，或折调，ˇ（∨），调值214（降升˨˩˦）</li>
<li>第四声，（去声，或降调，ˋ（\），调值51（全降˥˩）</li>
<li>eg：妈 mā  麻 má  马 mǎ  骂 mà  吗 mɑ</li>
<li>音标发音使用丹田发音</li>
</ol>
<h2 id="单元音"><a href="#单元音" class="headerlink" title="单元音"></a>单元音</h2><ul>
<li>长元音和短元音的区别不是拉长音，声音是一样的，之所以出现长短是因为口型引起的表象</li>
<li>口型小的，出气量少，时间显得长</li>
</ul>
<ol>
<li>[i:] =&gt; 读：yì（嘴型：龇牙咧嘴，齿间相对） eg：meat</li>
<li>[i] =&gt; 读：yì（嘴型：龇牙咧嘴，齿间具有一个小拇指空隙） eg：fish</li>
<li>[e] =&gt; 读：ài（嘴型：龇牙咧嘴，齿间具有一个食指空隙） eg：bench</li>
<li>[æ] =&gt; 读：ài（嘴型：龇牙咧嘴，齿间具有一个食指+中指空隙） eg：cat</li>
<li>[ɑ:] =&gt; 读：à（嘴型：压舌板，嘴型是一个近似0的椭圆形） eg：park</li>
<li>[ɔ] =&gt; 读：ào（嘴型：嘴型为o型） eg：not</li>
<li>[ɔ:] =&gt; 读：ào（嘴型：嘴型为o型，声音更加宏厚，可以比上一个更加用力，使用丹田） eg：corn</li>
<li>[u] =&gt; 读：wù（嘴型：一要噘嘴，二要把嘴唇翻过去） eg：look</li>
<li>[u:] =&gt; 读：wù（嘴型：一要噘嘴，二要把嘴唇翻过去，口型更小，好像亲一个人一样） eg：shoe</li>
<li>[ə:] =&gt; 读：è（嘴型：特别懒得音，气量足） eg：work</li>
<li>[ə] =&gt; 读：è（嘴型：特别懒得音，气量弱，有点气虚的感觉） eg：doctor</li>
<li>[ʌ] =&gt; 读：à（嘴型：口型大小在[ə]和[ɑ:]之间） eg：love</li>
</ol>
<h2 id="双元音"><a href="#双元音" class="headerlink" title="双元音"></a>双元音</h2><ul>
<li>双元音和单元音的区别是：单元音口型不发生变化，而双元音口型一定要变化</li>
</ul>
<ol>
<li>[ei] =&gt; 读：èi（嘴型：好像用嘴咬发糕，从大口到小口的过程） eg：tray</li>
<li>[ai] =&gt; 读：ā-yī的过渡（嘴型：两者之间的过渡，类似ài的音） eg：bike</li>
<li>[ɔi] =&gt; 读：ào-yì的过渡（嘴型：骑自行车要闯人时发的音） eg：boy</li>
<li>[əu] =&gt; 读：ǒu的过渡（嘴型：从扁口型到圆口型的过渡） eg：boat</li>
<li>[au] =&gt; 读：à-wū的过渡（嘴型：像老虎发音） eg：how</li>
</ol>
<ul>
<li>补充三个双元音</li>
</ul>
<ol>
<li>[iə] =&gt; 读：yì-è的过渡（嘴型：没有过多的变化，直接从前一个音过渡到后一个音，从重音到懒音的过程） eg：dear</li>
<li>[ɛə] =&gt; 读：ài-è的过渡（嘴型：没有过多的变化，直接从前一个音过渡到后一个音，从重音到懒音的过程） eg：share</li>
<li>[uə] =&gt; 读：wù-è的过渡（嘴型：没有过多的变化，直接从前一个音过渡到后一个音，从重音到懒音的过程） eg：poor</li>
</ol>
<ul>
<li>遇见能会读，不影响单词发音就是可以的，有些时候注音的音标只是辅助作用，最终决定发音的；是自己能够读清楚，不影响对话过程中的交流和理解，别人能懂就OK</li>
<li>千万不要为了学音标而学音标，目的是为了辅助发音和听懂别人说话</li>
<li>音标不是最终目的，说话才是最终目的</li>
</ul>
<h2 id="辅音"><a href="#辅音" class="headerlink" title="辅音"></a>辅音</h2><ul>
<li>不区别的，长得一模一样，发音一模一样的辅音</li>
</ul>
<h3 id="根据发音形式分为"><a href="#根据发音形式分为" class="headerlink" title="根据发音形式分为"></a>根据发音形式分为</h3><ol>
<li>清辅音：发音不震动</li>
<li>浊辅音：发音震动</li>
</ol>
<h3 id="十组对应的清浊辅音"><a href="#十组对应的清浊辅音" class="headerlink" title="十组对应的清浊辅音"></a>十组对应的清浊辅音</h3><table>
<thead>
<tr>
<th>序号</th>
<th>清辅音</th>
<th>浊辅音</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>[p] =&gt; 发音：po &lt;=&gt; eg：map</td>
<td>[b] =&gt; 发音：bō &lt;=&gt; eg：Bob</td>
</tr>
<tr>
<td>2</td>
<td>[t] =&gt; 发音：te &lt;=&gt; eg：tent</td>
<td>[d] =&gt; 发音：dē &lt;=&gt; eg：dad</td>
</tr>
<tr>
<td>3</td>
<td>[k] =&gt; 发音：ke &lt;=&gt; eg：keck</td>
<td>[g] =&gt; 发音：gē &lt;=&gt; eg：bag</td>
</tr>
<tr>
<td>4</td>
<td>[θ] =&gt; 发音：si &lt;=&gt; eg：math</td>
<td>[ð] =&gt; 发音：zī &lt;=&gt; eg：father</td>
<td>舌尖被上下齿咬住，清辅音只通风，浊辅音震动舌头有些痒痒的</td>
</tr>
<tr>
<td>5</td>
<td>[f] =&gt; 发音：fu &lt;=&gt; eg：fun</td>
<td>[v] =&gt; 发音：wù &lt;=&gt; eg：five</td>
<td>上齿咬下唇，像小姑娘一样</td>
</tr>
<tr>
<td>6</td>
<td>[s] =&gt; 发音：si &lt;=&gt; eg：boss</td>
<td>[z] =&gt; 发音：zì &lt;=&gt; eg：zip</td>
<td>舌头抵在上下齿附近</td>
</tr>
<tr>
<td>7</td>
<td>[ʃ] =&gt; 发音：shi &lt;=&gt; eg：fish</td>
<td>[ʒ] =&gt; 发音：rì &lt;=&gt; eg：usual</td>
<td>浊辅音特别想rì，但不rì</td>
</tr>
<tr>
<td>8</td>
<td>[tʃ] =&gt; 发音：chi &lt;=&gt; eg：catch</td>
<td>[dʒ] =&gt; 发音：zhì &lt;=&gt; eg：job</td>
<td>浊辅音特别想zhì，但不zhì</td>
</tr>
<tr>
<td>9</td>
<td>[ts] =&gt; 发音：ci &lt;=&gt; eg：cats</td>
<td>[dz] =&gt; 发音：zì- &lt;=&gt; eg：cards</td>
<td>浊辅音拉长音，这是和[z]的区别</td>
</tr>
<tr>
<td>10</td>
<td>[tr] =&gt; 发音：chua &lt;=&gt; eg：tree</td>
<td>[dr] =&gt; 发音：zhào &lt;=&gt; eg：dream</td>
</tr>
</tbody>
</table>
<ul>
<li>同一横行的是一对清浊辅音，之所以是同一对清浊辅音，就是因为口型一直，对应记忆</li>
<li>右半边忘了，记住左半边怎么读，声音震动一下音就出来了</li>
</ul>
<h4 id="其他浊辅音："><a href="#其他浊辅音：" class="headerlink" title="其他浊辅音："></a>其他浊辅音：</h4><p>[m] =&gt; 发音：en &lt;=&gt; eg：me（闭牙齿闭嘴唇发鼻音）<br>[n] =&gt; 发音：en &lt;=&gt; eg：noon（闭牙齿打开嘴唇发鼻音）<br>[ŋ] =&gt; 发音：en &lt;=&gt; eg：song（打开牙齿打开嘴唇发鼻音，闭嘴哼鸣音，逐渐张嘴）<br>[l] =&gt; 出现在元音音标前读：舌尖轻轻拍打上齿背，la；出现在元音音标后读：打自己一拳，ou =&gt; eg：school<br>[r] =&gt; rue =&gt; eg：ride<br>[w] =&gt; wo =&gt; 哪哪都不咬，嘴由圆打开就可以了 =&gt; eg：win<br>[j] =&gt; yue =&gt; yes 好像有好多个yi混淆一样，对的</p>
<h4 id="其他清辅音："><a href="#其他清辅音：" class="headerlink" title="其他清辅音："></a>其他清辅音：</h4><p>[h] =&gt; 发音：he &lt;=&gt; eg：hit（好像冬天我们进行哈气，短促有力）</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul>
<li>看一遍肯定是不够的，因为英语是一个需要重复的</li>
<li>一个不是一劳永逸的一个过程</li>
<li>一定要去重复，去加深自己的印象</li>
<li>督促自己，多听多练，才会出效果</li>
<li>只有不断的重复、模仿、对比、纠正，最终有一天会达到</li>
<li>归根结底：练！练！练！</li>
<li>多练习！多练习！多练习！</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/06/音标学习记录-国际音标/" data-id="cjbjiv6ug000erwdl1linolqd" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-github个人博客绑定单独阿里域名指南" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/30/github个人博客绑定单独阿里域名指南/" class="article-date">
  <time datetime="2017-11-30T14:22:35.000Z" itemprop="datePublished">2017-11-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/30/github个人博客绑定单独阿里域名指南/">github个人博客绑定单独阿里域名指南</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="github个人博客绑定单独阿里域名指南"><a href="#github个人博客绑定单独阿里域名指南" class="headerlink" title="github个人博客绑定单独阿里域名指南"></a>github个人博客绑定单独阿里域名指南</h1><p>[TOC]</p>
<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><ul>
<li>微信更新版本后出现了网页重拍版的问题，导致个人github博客无法进行分享</li>
<li>网页重拍版去掉了所有的a标签，禁止各种跳转功能；去掉所有的JS脚本</li>
<li>还有就是导致网站访问速度超级慢，换个域名顿时毫秒开</li>
</ul>
<h2 id="禁止微信重拍版"><a href="#禁止微信重拍版" class="headerlink" title="禁止微信重拍版"></a>禁止微信重拍版</h2><ol>
<li>要把网站的域名绑定在一个公众号上面（具体：登录认证公众号（<a href="http://mp.weixin.qq.com" target="_blank" rel="noopener">微信公众平台官网</a>）=&gt;;公众号设置 =&gt;;功能设置 =&gt;;业务域名 =&gt;;添加你的域名）</li>
<li>其次是必须是备案的域名，比如我github源地址：<code>liu12fei08fei.github.io</code>，是无法绑定到公众号的</li>
<li>需要购买一个域名，我买的是阿里云，然后备案，等待两周左右就可以享受到飞一般的感觉</li>
</ol>
<ul>
<li>注：其实只要绑定一个备案的域名就可以了，不需要在绑定公众号</li>
</ul>
<h2 id="给github-pages绑定域名"><a href="#给github-pages绑定域名" class="headerlink" title="给github pages绑定域名"></a>给github pages绑定域名</h2><h3 id="获取github-pages的ip地址"><a href="#获取github-pages的ip地址" class="headerlink" title="获取github pages的ip地址"></a>获取github pages的ip地址</h3><ol>
<li>打开你的电脑的命令行工具，ping你的github地址，忽略“/”后面的路径，比如我的github pages地址是liu12fei08fei.github.io/index.html，那么我需要ping的地址就是liu12fei08fei.github.io，如下图：<br><img src="/media/15120517556464/1.jpg" alt="1"></li>
<li>得到我们的ip地址：151.101.73.147</li>
</ol>
<ul>
<li>ping：ping是Windows、Unix和Linux系统下的一个命令。ping也属于一个通信协议，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。应用格式：Ping空格IP地址。该命令还可以加许多参数使用，具体是键入Ping按回车即可看到详细说明。</li>
</ul>
<h3 id="配置阿里云域名并解析（是域名就行，是不是阿里不重要）"><a href="#配置阿里云域名并解析（是域名就行，是不是阿里不重要）" class="headerlink" title="配置阿里云域名并解析（是域名就行，是不是阿里不重要）"></a>配置阿里云域名并解析（是域名就行，是不是阿里不重要）</h3><ol>
<li>进入你的阿里云的解析域名列表，选择你想要解析的域名，点击后面的解析。如下图所示：<br><img src="/media/15120517556464/2.jpg" alt="2"></li>
<li>点击 “解析” 进入具体操作详情页面，如图：<br><img src="/media/15120517556464/3.jpg" alt="3"></li>
<li>点击添加解析，如图：<br><img src="/media/15120517556464/4.jpg" alt="4"></li>
</ol>
<ul>
<li>说明：记录类型默认，主机记录第一次添加 “www” ，第二次添加 “@”</li>
<li>然后把其余的状态都改成禁止状态，不然会默认跳转到你之前定义的主机上（我踩的坑）</li>
</ul>
<h3 id="配置github-pages的custom-domain"><a href="#配置github-pages的custom-domain" class="headerlink" title="配置github pages的custom domain"></a>配置github pages的custom domain</h3><ol>
<li>进入你的github pages仓库（就是你博客的仓库）<br><img src="/media/15120517556464/6.jpg" alt="6"></li>
<li>点击Settings，在下面找到Custom domain<br><img src="/media/15120517556464/7.jpg" alt="7"><br>把之前的域名添加到输入框中，保存即可</li>
</ol>
<p>然后就可以访问这个配置好的域名，愉快的享受美好的人生了</p>
<h2 id="我配置好的博客"><a href="#我配置好的博客" class="headerlink" title="我配置好的博客"></a>我配置好的博客</h2><p><a href="http://www.liu12fei08fei.top/" target="_blank" rel="noopener">http://www.liu12fei08fei.top/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/30/github个人博客绑定单独阿里域名指南/" data-id="cjbjiv6u30005rwdltd3w50da" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-TypeScript入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/28/TypeScript入门/" class="article-date">
  <time datetime="2017-11-27T16:58:24.000Z" itemprop="datePublished">2017-11-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/28/TypeScript入门/">TypeScript入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="TypeScript入门"><a href="#TypeScript入门" class="headerlink" title="TypeScript入门"></a>TypeScript入门</h1><p>[TOC]</p>
<ol>
<li>微软开发一门编程语言</li>
<li>JavaScript的超集</li>
<li>遵循ES6脚本语言规范</li>
</ol>
<ul>
<li>TypeScript扩展了JavaScript的语法，任何已经存在的JS程序，可以不加任何改动的在TypeScript环境下运行</li>
<li>TypeScript只是向JS中添加一些新的，遵循ES6规范的语法，以及基于类的面向对象编程的这种特性</li>
<li>其次，2016年9月底发布的Angular2框架，这个框架本身是由TypeScript语言本身来编写的</li>
<li>TypeScript这门语言是由Microsoft（微软）和Google（谷歌），在背后支持</li>
<li>因此，TypeScript有可能称为前端脚本语言发展的一个主流方向</li>
</ul>
<h2 id="课程内容介绍"><a href="#课程内容介绍" class="headerlink" title="课程内容介绍"></a>课程内容介绍</h2><ol>
<li>学习TypeScript的好处</li>
<li>安装TypeScript开发环境</li>
<li>TypeScript概念、语法和特性介绍</li>
</ol>
<h2 id="课程介绍-前置知识"><a href="#课程介绍-前置知识" class="headerlink" title="课程介绍-前置知识"></a>课程介绍-前置知识</h2><ol>
<li>理解ES5、ES6、JavaScript、TypeScript的概念和关系<ol>
<li>ES是客户端脚本语言的规范，ES5、ES6是不同的版本</li>
<li>JavaScript和TypeScript是两种客户端脚本语言</li>
<li>JavaScript是实现了ES5规范，TypeScript实现了ES6规范</li>
</ol>
</li>
<li>有基础的JavaScript开发经验</li>
</ol>
<h2 id="TypeScript的优势"><a href="#TypeScript的优势" class="headerlink" title="TypeScript的优势"></a>TypeScript的优势</h2><ol>
<li>支持ES6规范</li>
<li>强大的IDE支持</li>
<li>Angular2的开发语言</li>
</ol>
<h2 id="搭建TypeScript开发环境"><a href="#搭建TypeScript开发环境" class="headerlink" title="搭建TypeScript开发环境"></a>搭建TypeScript开发环境</h2><ul>
<li>就是安装TypeScript compiler</li>
</ul>
<h3 id="什么是compiler？为什么需要compiler？"><a href="#什么是compiler？为什么需要compiler？" class="headerlink" title="什么是compiler？为什么需要compiler？"></a>什么是compiler？为什么需要compiler？</h3><ol>
<li>它是编译器，编译器的作用就是把TypeScript代码转化成JS代码</li>
<li>因为主流浏览器没有完全支持ES6，需要转化成ES5</li>
</ol>
<h3 id="使用在线compiler开发"><a href="#使用在线compiler开发" class="headerlink" title="使用在线compiler开发"></a><a href="http://www.typescriptlang.org/play/index.html" target="_blank" rel="noopener">使用在线compiler开发</a></h3><h3 id="搭建本地TypeScript开发环境"><a href="#搭建本地TypeScript开发环境" class="headerlink" title="搭建本地TypeScript开发环境"></a>搭建本地TypeScript开发环境</h3><h2 id="TypeScript-字符串新特性（所有例子都是es6语法）"><a href="#TypeScript-字符串新特性（所有例子都是es6语法）" class="headerlink" title="TypeScript-字符串新特性（所有例子都是es6语法）"></a>TypeScript-字符串新特性（所有例子都是es6语法）</h2><p>一、 多行字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = `111,</span><br><span class="line">222,</span><br><span class="line">333,</span><br><span class="line">444`;</span><br></pre></td></tr></table></figure>
<ul>
<li>多行字符串使用双撇号声明变量（即：反引号），好处是可以随意换行无需拼接字符串</li>
</ul>
<p>二、 字符串模板：在多行字符串里，用一个表达式去插入变量或者用以调用方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var myName = &apos;怪诞咖啡&apos;;</span><br><span class="line"></span><br><span class="line">var getName = function () &#123;</span><br><span class="line">    return myName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(`Hello $&#123;myName&#125;`); // 调用变量</span><br><span class="line">console.log(`Hello $&#123;getName()&#125;`); // 调用函数</span><br></pre></td></tr></table></figure>
<ul>
<li>注：字符串模板<code>${}</code>，只有在反引号``中有作用，在双引号（””）和单引号（’’）中只会当字符串输出</li>
</ul>
<p>三、 自动拆分字符串：当用一个字符串模板去调用一个方法的时候，这个字符串模板里面表达式的值会自动赋值给被调用方法中的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function test(name, age, job) &#123;</span><br><span class="line">    console.log(name);</span><br><span class="line">    console.log(age);</span><br><span class="line">    console.log(job);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var myName = &quot;怪诞咖啡&quot;;</span><br><span class="line">var getAge = function () &#123;</span><br><span class="line">    return 18;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test`Hello my name is $&#123;myName&#125;, I&apos;m $&#123;getAge()&#125;`;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用test函数，进行参数传递时候，不需要写双括号，直接使用反引号</li>
<li>第一个参数是：字符串模板的值 =&gt; [“Hello my name is “,”, I’m “,””]</li>
<li>第二个参数是：第一个表达式的值 =&gt; 怪诞咖啡</li>
<li>第三个参数是：第二个表达式的值 =&gt; 18</li>
</ul>
<h2 id="TypeScript-参数新特性"><a href="#TypeScript-参数新特性" class="headerlink" title="TypeScript-参数新特性"></a>TypeScript-参数新特性</h2><h3 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h3><p>一、 在参数名称后面使用冒号来指定参数的类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var myName: string = &apos;怪诞咖啡&apos;;</span><br><span class="line"></span><br><span class="line">myName = 13;</span><br></pre></td></tr></table></figure>
<ul>
<li>注：报错只会在typescript环境下，在编译后的es5环境下是不会报错的</li>
</ul>
<p>二、 类型推断机制，就是当第一次给变量赋值，此变量的类型就固定为第一次赋值的类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var myName = &apos;怪诞咖啡&apos;;</span><br><span class="line"></span><br><span class="line">myName = 13;</span><br></pre></td></tr></table></figure>
<ul>
<li>注：报错只会在typescript环境下，在编译后的es5环境下是不会报错的</li>
</ul>
<p>三、 要想在typescript环境下任意赋值，就需要赋值为:any</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var myName:any = &apos;怪诞咖啡&apos;;</span><br><span class="line"></span><br><span class="line">myName = 13;</span><br></pre></td></tr></table></figure>
<p>四、 其他基本类型</p>
<ol>
<li>数值类型 var num: number = 20;</li>
<li>布尔类型 var boo: boolean = true;</li>
<li>void类型：void不是用来声明变量的，而是用来声明变量的返回值的</li>
</ol>
<p>void类型例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function test(): void&#123;</span><br><span class="line">    return &apos;&apos;; // 报错</span><br><span class="line">&#125;</span><br><span class="line">function test(): string&#123;</span><br><span class="line">    return &apos;&apos;; // 不报错</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>五、 除了给变量和函数声明类型外，还可以给参数声明类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function test(name: string, age) &#123;</span><br><span class="line">    return name;</span><br><span class="line">&#125;</span><br><span class="line">test(1); // 报错，只能使用string类型进行调用</span><br></pre></td></tr></table></figure>
<p><strong>注：介绍了如何声明类型、typescript类型推断机制、五种基本的类型、可以声明类型的位置</strong></p>
<p>六、 自定义类型：在typescript里面，可以通过class或接口来申明自定义类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var feifei: Person = new Person();</span><br><span class="line">feifei.name = &apos;怪诞咖啡&apos;;</span><br><span class="line">feifei.age = 18;</span><br></pre></td></tr></table></figure>
<ul>
<li>当我们写feifei.的时候会提示Person有name和age两个属性</li>
</ul>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>在参数声明后面用等号来指定参数的默认值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test(a: string, b: string, c: string) &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(b);</span><br><span class="line">    console.log(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(&apos;1&apos;,&apos;2&apos;,&apos;3&apos;); // 必须传递三个string类型的参数，否则提示错误</span><br></pre></td></tr></table></figure>
<p>给参数指定默认值之后，可以不传递参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test(a: string, b: string, c: string=&apos;攻城狮&apos;) &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(b);</span><br><span class="line">    console.log(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(&apos;1&apos;, &apos;2&apos;); // 只传递两个参数，第三个参数使用默认值</span><br></pre></td></tr></table></figure>
<ul>
<li>默认值的设定应该遵循从右向左一次设定，否则无法起到合理的作用</li>
</ul>
<h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>在方法的参数声明后面用问号来标明此参数为可选参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test(a: string, b?: string, c: string=&apos;攻城狮&apos;) &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(b);</span><br><span class="line">    console.log(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(&apos;1&apos;); // 只传递一个参数，第二个参数为undefined，第三个参数为默认值</span><br></pre></td></tr></table></figure>
<p>注意几点：</p>
<ul>
<li>b设置为可选参数，要处理可选参数没传的情况</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test(a: string, b?: string, c: string=&apos;攻城狮&apos;) &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(b.length);</span><br><span class="line">    console.log(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：b参数为可选参数，在不传递参数值的情况下是不允许调用undefined的length属性的</p>
<ul>
<li>和默认值一样，可选参数不能声明在必选参数的后面的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test(a?: string, b: string, c: string=&apos;攻城狮&apos;) &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(b);</span><br><span class="line">    console.log(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：我给a设置为可选参数，b为必选参数，会直接报错；和设置默认值是一样的，不允许在必选参数前面设置默认值</p>
<h2 id="函数新特性"><a href="#函数新特性" class="headerlink" title="函数新特性"></a>函数新特性</h2><h3 id="Rest-and-Spread操作符（…）：用来声明任意数量的方法参数，即rest参数"><a href="#Rest-and-Spread操作符（…）：用来声明任意数量的方法参数，即rest参数" class="headerlink" title="Rest and Spread操作符（…）：用来声明任意数量的方法参数，即rest参数"></a>Rest and Spread操作符（…）：用来声明任意数量的方法参数，即rest参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function fun(...args) &#123;</span><br><span class="line">    args.forEach(function (arg) &#123; </span><br><span class="line">        console.log(arg);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun(1, 2, 3);</span><br><span class="line">console.log(&apos;******&apos;); // 分隔符</span><br><span class="line">fun(10,8,18,49,100,7)</span><br></pre></td></tr></table></figure>
<p><strong>一个Rest and Spread操作符，反方向使用的方法–目前版本2.6不支持</strong></p>
<ul>
<li>设置传递固定数量的参数，在使用的时候传递不定数量的参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function fun(a, b, c) &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(b);</span><br><span class="line">    console.log(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var args = [1, 2];</span><br><span class="line">fun(...args); // 在typescript中报错，在转化的es5中支持，返回值为：1 2 undefined</span><br><span class="line"></span><br><span class="line">console.log(&apos;*****&apos;);</span><br><span class="line"></span><br><span class="line">var args2 = [7, 8, 9, 10, 12];</span><br><span class="line">fun(...args2); // 在typescript中报错，在转化的es5中支持，返回值为：7 8 9</span><br></pre></td></tr></table></figure>
<h3 id="generator函数：控制函数的执行过程，手工暂停和恢复代码执行"><a href="#generator函数：控制函数的执行过程，手工暂停和恢复代码执行" class="headerlink" title="generator函数：控制函数的执行过程，手工暂停和恢复代码执行"></a>generator函数：控制函数的执行过程，手工暂停和恢复代码执行</h3><ol>
<li>在es5中，调用一个方法的时候，没有办法在函数执行到一半的时候，进行暂停执行</li>
<li>在es6中，新加一个关键字yield，这个关键字可以实现方法暂停执行；yield就好像给代码加上了断点一样，可以通过编程的手段，控制代码走到某个点暂停执行，然后调用特定方法的时候在进行，可以往复循环</li>
</ol>
<p>声明一个generator函数，只要在function后面添加一个<em>即可：`function</em> fun(){}`</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function* fun()&#123;</span><br><span class="line">  console.log(&apos;start&apos;);</span><br><span class="line">  </span><br><span class="line">  yield;</span><br><span class="line">  </span><br><span class="line">  console.log(&apos;finish&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// fun(); // 这样调用generator是不起作用的，必须使用下面的方式调用</span><br><span class="line"></span><br><span class="line">var fn = fun();</span><br><span class="line">fn.next(); // 打印start</span><br><span class="line"></span><br><span class="line">fn.next(); // 打印finish</span><br></pre></td></tr></table></figure>
<h3 id="destructuring析构表达式：通过表达式将对象或数组拆解成任意数量的变量"><a href="#destructuring析构表达式：通过表达式将对象或数组拆解成任意数量的变量" class="headerlink" title="destructuring析构表达式：通过表达式将对象或数组拆解成任意数量的变量"></a>destructuring析构表达式：通过表达式将对象或数组拆解成任意数量的变量</h3><ul>
<li>从对象中通过析构表达式获得相应属性和方法，对象析构是用<code>{}</code>大括号声明</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    myName: &apos;怪诞咖啡&apos;,</span><br><span class="line">    age: &#123;</span><br><span class="line">      age1: 18,</span><br><span class="line">      age2:80</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var &#123; myName, age: &#123; age1, age2 &#125; &#125; = a(); // 析构表达式，包括嵌套属性</span><br><span class="line"></span><br><span class="line">var &#123; myName:newName, age: &#123; age1, age2 &#125; &#125; = a(); // 析构表达式，给myName起一个新的名字newName</span><br><span class="line"></span><br><span class="line">console.log(age1);</span><br><span class="line">console.log(age2);</span><br></pre></td></tr></table></figure>
<p>解析：返回值，即<code>return</code>返回值，的结构和我们的析构表达式的结构<code>{ myName, age: { age1, age2 } }</code>一一对应，所以析构表达式，即可理解为，解析结构获得对象属性的方法</p>
<ul>
<li>从数组中通过析构表达式获得相应属性和方法，数组析构是用<code>[]</code>方括号声明</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4];</span><br><span class="line">var [num1, num2, ...other] = arr; // 获取第一个和第二个，其余变量赋值给other</span><br><span class="line">var [,,num3,num4] = arr; // 获取第三和第四个值</span><br></pre></td></tr></table></figure>
<p>析构表达式好处：当你需要从一个对象的属性或者是数组的元素里面，用其中的值赋值给其余变量的时候，可以让我们写更少的代码</p>
<h2 id="表达式和循环"><a href="#表达式和循环" class="headerlink" title="表达式和循环"></a>表达式和循环</h2><h3 id="箭头表达式：用来声明匿名函数，消除传统匿名函数的this指针问题"><a href="#箭头表达式：用来声明匿名函数，消除传统匿名函数的this指针问题" class="headerlink" title="箭头表达式：用来声明匿名函数，消除传统匿名函数的this指针问题"></a>箭头表达式：用来声明匿名函数，消除传统匿名函数的this指针问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 无参数表达式</span><br><span class="line">var sum = () =&gt; &#123;&#125;</span><br><span class="line">// 只有一个参数的表达式</span><br><span class="line">var sum = arg =&gt; &#123;&#125;</span><br><span class="line">// 单行表达式</span><br><span class="line">var sum = (arg1, arg2) =&gt; arg1 + arg2;</span><br><span class="line">// 多行表达式</span><br><span class="line">var sum2 = (arg1, arg2) =&gt; &#123;</span><br><span class="line">  return arg1 + arg2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5];</span><br><span class="line">var flt = arr.filter(val =&gt; val % 2 == 0);</span><br><span class="line">console.log(flt);</span><br></pre></td></tr></table></figure>
<p>箭头函数的优势：</p>
<ol>
<li>简化书写</li>
<li>最大的优势，消除了js里，this关键字的问题</li>
</ol>
<ul>
<li>this指向问题</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function fn(myName: string) &#123;</span><br><span class="line">  this.myName = myName;</span><br><span class="line"></span><br><span class="line">  setInterval(function () &#123;</span><br><span class="line">    console.log(&apos;myName is：&apos;+this.myName);</span><br><span class="line">  &#125;,1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var myName = 1; // 全局myName，后面的this指向了全局，而不是a</span><br><span class="line">var a = new fn(&apos;怪诞咖啡&apos;);</span><br></pre></td></tr></table></figure>
<ul>
<li>改用箭头函数，消除this指向问题</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function fn(myName: string) &#123;</span><br><span class="line">  this.myName = myName;</span><br><span class="line"></span><br><span class="line">  setInterval(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;myName is：&apos;+this.myName);</span><br><span class="line">  &#125;,1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var myName = 1;</span><br><span class="line">var a = new fn(&apos;怪诞咖啡&apos;); // 消除指向问题</span><br></pre></td></tr></table></figure>
<h3 id="forEach-、for-in和for-of"><a href="#forEach-、for-in和for-of" class="headerlink" title="forEach()、for in和for of"></a>forEach()、for in和for of</h3><h4 id="forEach："><a href="#forEach：" class="headerlink" title="forEach："></a>forEach：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4];</span><br><span class="line">arr.desc = &apos;I am number type!&apos;; // 这行在typescript里面会报错</span><br><span class="line"></span><br><span class="line">arr.forEach(val =&gt; console.log(val));</span><br></pre></td></tr></table></figure>
<p>问题：</p>
<ol>
<li>forEach会把desc属性忽略掉</li>
<li>foeEach里面无法打断循环，break不支持</li>
</ol>
<h4 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [11, 22, 33, 44];</span><br><span class="line">arr.desc = &apos;I am number type!&apos;;</span><br><span class="line"></span><br><span class="line">for (var item in arr) &#123;</span><br><span class="line">  console.log(item); // key=&gt; 1,2,3,4,desc</span><br><span class="line">  console.log(arr[item]); //value=&gt;11,22,33,44,I am number type! </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题：</p>
<ul>
<li>不光把数组里面的值循环出来，同样会把定义的属性也循环出来；结果很可能不是我们希望的样子</li>
</ul>
<h4 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h4><ol>
<li>和forEach差不错，循环的是你对象或数组的值，而不是像for in循环的key</li>
<li>for of和forEach的差别是，可以用break可以打断循环</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [11, 22, 33, 44];</span><br><span class="line">arr.desc = &apos;I am number type!&apos;;</span><br><span class="line"></span><br><span class="line">for (var item of arr) &#123;</span><br><span class="line">  console.log(item); // key=&gt; 11,22,33,44 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面向对象特性"><a href="#面向对象特性" class="headerlink" title="面向对象特性"></a>面向对象特性</h2><h3 id="类（class）：TypeScript的核心，使用TypeScript开发时，大部分代码都是写在类里面的。"><a href="#类（class）：TypeScript的核心，使用TypeScript开发时，大部分代码都是写在类里面的。" class="headerlink" title="类（class）：TypeScript的核心，使用TypeScript开发时，大部分代码都是写在类里面的。"></a>类（class）：TypeScript的核心，使用TypeScript开发时，大部分代码都是写在类里面的。</h3><ul>
<li>这里会介绍类的定义，构造函数，以及类的继承</li>
</ul>
<h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h4><ul>
<li>使用class关键字声明类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以指定类的属性和方法，一个完整的类具有属性和方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  name;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    console.log(&apos;I am eating!&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>实例化：可以把类理解成为一个模子；所谓实例化，就是根据模子做出实际的产品出来</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  name;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    console.log(&apos;I am eating!&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 = new Person();</span><br><span class="line">p1.name = &apos;Hello&apos;;</span><br><span class="line">p1.eat();</span><br><span class="line"></span><br><span class="line">var p2 = new Person();</span><br><span class="line">p2.name = &apos;World&apos;;</span><br><span class="line">p2.eat();</span><br></pre></td></tr></table></figure>
<h4 id="返回控制符"><a href="#返回控制符" class="headerlink" title="返回控制符"></a>返回控制符</h4><ul>
<li>在声明类的属性和方法的时候，可以为其指定一个返回控制符</li>
<li>返回控制符的作用是控制类的属性和方法是否可以在外部被访问到</li>
<li>返回控制符有三个：<ol>
<li>public共用，默认public</li>
<li>private私有，只有在类的内部才能被访问到，在外部访问不到</li>
<li>protected受保护的，可以在类的内部和子类（继承）里面可以被访问到，在外部访问不到</li>
</ol>
</li>
</ul>
<h4 id="类的构造函数，即：constructor方法"><a href="#类的构造函数，即：constructor方法" class="headerlink" title="类的构造函数，即：constructor方法"></a>类的构造函数，即：constructor方法</h4><ul>
<li>实际上是类里面一个特殊的方法，这个方法只有在类被实例化的时候才会被调用</li>
<li>而且只会调用一次</li>
<li>外部无法访问到constructor构造函数的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    console.log(&apos;构造函数&apos;)</span><br><span class="line">  &#125;;</span><br><span class="line">  name=&apos;默认值&apos;;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    console.log(&apos;I am eating!&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 = new Person();</span><br><span class="line">p1.name = &apos;Hello&apos;;</span><br><span class="line">p1.eat();</span><br><span class="line"></span><br><span class="line">var p2 = new Person();</span><br><span class="line">p2.name = &apos;World&apos;;</span><br><span class="line">p2.eat();</span><br></pre></td></tr></table></figure>
<p>构造函数的作用：可以在实例化的时候，指定相应属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  constructor(public name:string) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  eat() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 = new Person(&apos;Hello&apos;);</span><br><span class="line">p1.eat();</span><br><span class="line"></span><br><span class="line">var p2 = new Person(&apos;World&apos;);</span><br><span class="line">p2.eat();</span><br></pre></td></tr></table></figure>
<p>注意：构造函数里面，定义属性，要使用控制符来明确声明，即：<code>public name:any</code>；如果是<code>name:any</code>这样，说明没有声明该属性，下面无法访问到</p>
<h4 id="类的继承：两个关键字"><a href="#类的继承：两个关键字" class="headerlink" title="类的继承：两个关键字"></a>类的继承：两个关键字</h4><ol>
<li>一个是extends，用来声明类的继承关系</li>
<li>另一个是super，用来调用父类的构造函数和方法</li>
</ol>
<h5 id="extends，获得继承类中所有属性和方法"><a href="#extends，获得继承类中所有属性和方法" class="headerlink" title="extends，获得继承类中所有属性和方法"></a>extends，获得继承类中所有属性和方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  constructor(public name:string) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  eat() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Employee extends Person&#123;</span><br><span class="line">  // 定义新的属性和方法</span><br><span class="line">  code: string;</span><br><span class="line"></span><br><span class="line">  work() &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let em = new Employee(&apos;coffee&apos;);</span><br><span class="line">em.eat();</span><br></pre></td></tr></table></figure>
<h5 id="super"><a href="#super" class="headerlink" title="super"></a>super</h5><h6 id="调用父类的构造函数"><a href="#调用父类的构造函数" class="headerlink" title="调用父类的构造函数"></a>调用父类的构造函数</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  constructor(public name:string) &#123;</span><br><span class="line">    console.log(&apos;父类构造函数&apos;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  eat() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Employee extends Person&#123;</span><br><span class="line"></span><br><span class="line">  constructor(name: string, code: string) &#123; </span><br><span class="line">    // 必须调用父类的构造函数，这是硬性规定</span><br><span class="line">    super(name);</span><br><span class="line">    console.log(&apos;子类构造函数&apos;);</span><br><span class="line">    this.code = code;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  code: string;</span><br><span class="line"></span><br><span class="line">  work() &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let em = new Employee(&apos;coffee&apos;,&apos;8&apos;);</span><br><span class="line">em.eat();</span><br></pre></td></tr></table></figure>
<h6 id="用来调用父类的方法"><a href="#用来调用父类的方法" class="headerlink" title="用来调用父类的方法"></a>用来调用父类的方法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  constructor(public name:string) &#123;</span><br><span class="line">    console.log(&apos;父类构造函数&apos;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  eat() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Employee extends Person&#123;</span><br><span class="line"></span><br><span class="line">  constructor(name: string, code: string) &#123; </span><br><span class="line">    // 必须调用父类的构造函数，这是硬性规定</span><br><span class="line">    super(name);</span><br><span class="line">    console.log(&apos;子类构造函数&apos;);</span><br><span class="line">    this.code = code;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  code: string;</span><br><span class="line"></span><br><span class="line">  work() &#123;</span><br><span class="line">    // 调用父类的方法</span><br><span class="line">    super.eat();</span><br><span class="line">  &#125;;</span><br><span class="line">  // 返回控制符</span><br><span class="line">  private doWork() &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let em = new Employee(&apos;coffee&apos;,&apos;8&apos;);</span><br><span class="line">em.work();</span><br></pre></td></tr></table></figure>
<h3 id="面向对象特性-1"><a href="#面向对象特性-1" class="headerlink" title="面向对象特性"></a>面向对象特性</h3><h4 id="泛型-generic：是指参数化的类型，一般用来限制集合的内容"><a href="#泛型-generic：是指参数化的类型，一般用来限制集合的内容" class="headerlink" title="泛型-generic：是指参数化的类型，一般用来限制集合的内容"></a>泛型-generic：是指参数化的类型，一般用来限制集合的内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  constructor(public name:string) &#123;</span><br><span class="line">    console.log(&apos;父类构造函数&apos;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  eat() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Employee extends Person&#123;</span><br><span class="line"></span><br><span class="line">  constructor(name: string, code: string) &#123; </span><br><span class="line">    // 必须调用父类的构造函数，这是硬性规定</span><br><span class="line">    super(name);</span><br><span class="line">    console.log(&apos;子类构造函数&apos;);</span><br><span class="line">    this.code = code;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  code: string;</span><br><span class="line"></span><br><span class="line">  work() &#123;</span><br><span class="line">    // 调用父类的方法</span><br><span class="line">    super.eat();</span><br><span class="line">  &#125;;</span><br><span class="line">  private doWork() &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var workers: Array&lt;Person&gt; = [];</span><br><span class="line">workers[0] = new Person(&apos;神经了&apos;);</span><br><span class="line">workers[1] = new Employee(&apos;神经了&apos;, &apos;8&apos;);</span><br><span class="line">workers[2] = 3; // 报错，指定放Person类型的数据</span><br></pre></td></tr></table></figure>
<h4 id="接口-Interface：用来建立某种代码约定，使得其它开发者在调用某个方法或创建新的类时必须遵循接口所定义的代码约定"><a href="#接口-Interface：用来建立某种代码约定，使得其它开发者在调用某个方法或创建新的类时必须遵循接口所定义的代码约定" class="headerlink" title="接口-Interface：用来建立某种代码约定，使得其它开发者在调用某个方法或创建新的类时必须遵循接口所定义的代码约定"></a>接口-Interface：用来建立某种代码约定，使得其它开发者在调用某个方法或创建新的类时必须遵循接口所定义的代码约定</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface IPerson&#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">  constructor(public config:IPerson)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 声明属性</span><br><span class="line">var p1 = new Person(&#123;</span><br><span class="line">  name: &apos;coffee&apos;,</span><br><span class="line">  age:8</span><br><span class="line">&#125;);</span><br><span class="line">console.log(p1);</span><br></pre></td></tr></table></figure>
<p>实现对应的接口中的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface Animal&#123;</span><br><span class="line">  eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Sheep implements Animal&#123;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    console.log(&apos;I eat grass&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Tiger implements Animal&#123;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    console.log(&apos;I eat meat&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模块-module：模块可以帮助开发者将代码分割为可重用的单元。开发者可以自己决定将模块中的哪些资源（类、方法、变量）暴露出去供外部使用，哪些资源只在模块内使用。"><a href="#模块-module：模块可以帮助开发者将代码分割为可重用的单元。开发者可以自己决定将模块中的哪些资源（类、方法、变量）暴露出去供外部使用，哪些资源只在模块内使用。" class="headerlink" title="模块-module：模块可以帮助开发者将代码分割为可重用的单元。开发者可以自己决定将模块中的哪些资源（类、方法、变量）暴露出去供外部使用，哪些资源只在模块内使用。"></a>模块-module：模块可以帮助开发者将代码分割为可重用的单元。开发者可以自己决定将模块中的哪些资源（类、方法、变量）暴露出去供外部使用，哪些资源只在模块内使用。</h4><ol>
<li>模块在typescript里面就是一个文件，一个文件就是一个模块</li>
<li>在模块内部有两个关键字来支撑模块的特性，export暴露接口、import</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 文件a</span><br><span class="line">import &#123;newName&#125; from &quot;./b&quot;; // 引入b文件，使用b文件中提供的接口newName</span><br><span class="line"></span><br><span class="line">// a文件对外提供接口</span><br><span class="line">export var prop1;</span><br><span class="line">var prop2;</span><br><span class="line">export function func1()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">function func2()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export class Class1&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Class2&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 获得b文件提供的接口</span><br><span class="line">console.log(newName);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// b文件</span><br><span class="line">import &#123;Class1, func1, prop1&#125; from &quot;./a&quot;; // 引入a文件</span><br><span class="line">// 获取a文件提供的接口</span><br><span class="line">console.log(prop1);</span><br><span class="line"></span><br><span class="line">func1();</span><br><span class="line"></span><br><span class="line">new Class1&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 对外提供接口</span><br><span class="line">export var newName;</span><br></pre></td></tr></table></figure>
<h4 id="注解-annotation：注解为程序的元素（类、方法、变量）加上更直观更明了的说明，这些说明信息与程序的业务逻辑无关，而是供指定的工具或框架使用的"><a href="#注解-annotation：注解为程序的元素（类、方法、变量）加上更直观更明了的说明，这些说明信息与程序的业务逻辑无关，而是供指定的工具或框架使用的" class="headerlink" title="注解-annotation：注解为程序的元素（类、方法、变量）加上更直观更明了的说明，这些说明信息与程序的业务逻辑无关，而是供指定的工具或框架使用的"></a>注解-annotation：注解为程序的元素（类、方法、变量）加上更直观更明了的说明，这些说明信息与程序的业务逻辑无关，而是供指定的工具或框架使用的</h4><h4 id="类型定义文件（-d-ts）：类型定义文件用来帮助开发者在TypeScript中使用已有的JS的工具包；如：jQuery、zepto等"><a href="#类型定义文件（-d-ts）：类型定义文件用来帮助开发者在TypeScript中使用已有的JS的工具包；如：jQuery、zepto等" class="headerlink" title="类型定义文件（*.d.ts）：类型定义文件用来帮助开发者在TypeScript中使用已有的JS的工具包；如：jQuery、zepto等"></a>类型定义文件（*.d.ts）：类型定义文件用来帮助开发者在TypeScript中使用已有的JS的工具包；如：jQuery、zepto等</h4><p>如何找到类型定义文件，肯定不能自己一个个的写；使用tyings来快速启动</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/28/TypeScript入门/" data-id="cjbjiv6u20004rwdlhd2mp46q" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-搜索引擎命令大全！" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/25/搜索引擎命令大全！/" class="article-date">
  <time datetime="2017-11-25T12:36:35.000Z" itemprop="datePublished">2017-11-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/25/搜索引擎命令大全！/">搜索引擎命令大全！</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="搜索引擎命令大全！"><a href="#搜索引擎命令大全！" class="headerlink" title="搜索引擎命令大全！"></a>搜索引擎命令大全！</h1><p>[TOC]</p>
<h2 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h2><p>把搜索词放在双引号中，代表完全匹配搜索，也就是说搜索结果返回的页面包含双引号中出现的所有的词，连顺序也必须完全匹配。</p>
<p>bd和Google 都支持这个指令。</p>
<p>例如搜索： “seo方法图片”</p>
<h2 id="减号"><a href="#减号" class="headerlink" title="减号"></a>减号</h2><p>减号代表搜索不包含减号后面的词的页面。</p>
<p>使用这个指令时减号前面必须是空格，减号后面没有空格，紧跟着需要排除的词。</p>
<p>Google 和bd都支持这个指令。</p>
<p>例如：搜索 -引擎</p>
<p>返回的则是包含“搜索”这个词，却不包含“引擎”这个词的结果</p>
<h2 id="星号"><a href="#星号" class="headerlink" title="星号"></a>星号</h2><p>星号<code>*</code>是常用的通配符，也可以用在搜索中。</p>
<p>百度不支持<code>*</code>号搜索指令。</p>
<p>比如在Google 中搜索：搜索<code>*</code>擎</p>
<p>其中的<code>*</code>号代表任何文字。返回的结果就不仅包含“搜索引擎”，还包含了“搜索收擎”，“搜索巨擎”等内容。</p>
<h2 id="inurl"><a href="#inurl" class="headerlink" title="inurl"></a>inurl</h2><p>指令用于搜索查询词出现在url 中的页面。</p>
<p>bd和Google 都支持inurl 指令。</p>
<p>inurl 指令支持中文和英文。</p>
<p>比如搜索：inurl:搜索引擎优化</p>
<p>返回的结果都是网址url 中包含“搜索引擎优化”的页面。由于关键词出现在url 中对排名有一定影响，使用inurl:搜索可以更准确地找到竞争对手。</p>
<h2 id="inanchor"><a href="#inanchor" class="headerlink" title="inanchor"></a>inanchor</h2><p>指令返回的结果是导入链接锚文字中包含搜索词的页面。</p>
<p>百度不支持inanchor。</p>
<p>比如在Google 搜索 ：inanchor:点击这里返回的结果页面本身并不一定包含“点击这里”这四个字，而是指向这些页面的链接锚文字中出现了“点击这里”这四个字。</p>
<p>可以用来找到某个关键词的竞争对手，而且这些竞争对手往往是做过SEO 的。</p>
<p>研究竞争对手页面有哪些外部链接，就可以找到很多链接资源。</p>
<h2 id="intitle"><a href="#intitle" class="headerlink" title="intitle"></a>intitle</h2><p>指令返回的是页面title 中包含关键词的页面。</p>
<p>Google 和bd都支持intitle 指令。</p>
<p>使用intitle 指令找到的文件是更准确的竞争页面。</p>
<p>如果关键词只出现在页面可见文字中，而没有出现在title 中，大部分情况是并没有针对关键词进行优化，所以也不是有力的竞争对手。</p>
<h2 id="allintitle"><a href="#allintitle" class="headerlink" title="allintitle"></a>allintitle</h2><p>搜索返回的是页面标题中包含多组关键词的文件。</p>
<p>例如 ：allintitle:SEO 搜索引擎优化</p>
<p>就相当于：intitle:SEO intitle:搜索引擎优化</p>
<p>返回的是标题中中既包含“SEO”，也包含“搜索引擎优化”的页面</p>
<h2 id="allinurl"><a href="#allinurl" class="headerlink" title="allinurl"></a>allinurl</h2><p>与allintitle: 类似。</p>
<p>allinurl:SEO 搜索引擎优化</p>
<p>就相当于 ：inurl:SEO inurl:搜索引擎优化</p>
<h2 id="filetype"><a href="#filetype" class="headerlink" title="filetype"></a>filetype</h2><p>用于搜索特定文件格式。</p>
<p>Google 和bd都支持filetype 指令。</p>
<p>比如搜索filetype:pdf SEO</p>
<p>返回的就是包含SEO 这个关键词的所有pdf 文件。</p>
<h2 id="site"><a href="#site" class="headerlink" title="site"></a>site</h2><p>是SEO 最熟悉的高级搜索指令，用来搜索某个域名下的所有文件。</p>
<p>注意事项：</p>
<ol>
<li>site:后边跟的冒号必须是英文的“:”，中文的全角冒号“：”无用</li>
<li>网址前不能带“http://”</li>
<li>网址后边不能带斜杠“/”，其实是哪里都不能带“/”</li>
<li>网址中不要用“www”，除非你有特别目的，用“www”会导致错过网站内的内容，因为很多网站的频道是没有“www”的</li>
</ol>
<h2 id="linkdomain"><a href="#linkdomain" class="headerlink" title="linkdomain"></a>linkdomain</h2><p>指令只适用于雅虎，返回的是某个域名的反向链接。雅虎的反向链接数据还比较准<br>确，是SEO 人员研究竞争对手外部链接情况的重要工具之一。</p>
<p>比如搜索linkdomain:<a href="http://cnseotool.com" target="_blank" rel="noopener">http://cnseotool.com</a> -site:<a href="http://cnseotool.com得到的就是点石网站的外部链接，因为-site:http://cnseotool.com" target="_blank" rel="noopener">http://cnseotool.com得到的就是点石网站的外部链接，因为-site:http://cnseotool.com</a> 已经排除了点石本身的页面，也就是内部链接，剩下的就都是外部链接了。</p>
<h2 id="related"><a href="#related" class="headerlink" title="related"></a>related</h2><p>指令只适用于Google，返回的结果是与某个网站有关联的页面。比如搜索</p>
<p>related:<a href="http://cnseotool.com" target="_blank" rel="noopener">http://cnseotool.com</a></p>
<p>我们就可以得到Google 所认为的与点石网站有关联的其他页面。</p>
<p>这种关联到底指的是什么，Google 并没有明确说明，一般认为指的是有共同外部链接的网站。</p>
<h2 id="知乎整理"><a href="#知乎整理" class="headerlink" title="知乎整理"></a>知乎整理</h2><p><a href="https://www.zhihu.com/question/20161362/answer/14180620" target="_blank" rel="noopener">来源：知乎，作者：崔凯</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/25/搜索引擎命令大全！/" data-id="cjbjiv6ud000crwdl8dh2xby9" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux入门基础篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/22/Linux入门基础篇/" class="article-date">
  <time datetime="2017-11-22T14:17:20.000Z" itemprop="datePublished">2017-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/22/Linux入门基础篇/">Linux入门基础篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Linux入门基础篇"><a href="#Linux入门基础篇" class="headerlink" title="Linux入门基础篇"></a>Linux入门基础篇</h1><p>[TOC]</p>
<h2 id="Linux诞生"><a href="#Linux诞生" class="headerlink" title="Linux诞生"></a>Linux诞生</h2><ol>
<li>Linux操作系统诞生于1991年10月5日（这是第一次正式向外公布时间）。</li>
<li>Linux存在着许多不同的Linux版本，但它们都使用了Linux内核。</li>
<li>Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、视频游戏控制台、台式计算机、大型机和超级计算机。</li>
</ol>
<h2 id="Linux发行版本说明"><a href="#Linux发行版本说明" class="headerlink" title="Linux发行版本说明"></a>Linux发行版本说明</h2><ol>
<li>Linux的发行版说简单点就是将Linux内核与应用软件做一个打包</li>
<li>较知名的发行版有：Ubuntu、RedHat、CentOS、Debain、Fedora、SuSE、OpenSUSE、TurboLinux、BluePoint、RedFlag、Xterm、SlackWare等</li>
</ol>
<h2 id="Linux官方网站"><a href="#Linux官方网站" class="headerlink" title="Linux官方网站"></a><a href="https://www.linux.org/" target="_blank" rel="noopener">Linux官方网站</a></h2><ol>
<li>Ubuntu 和 CentOS 用的比较多</li>
<li>Debian 在国内用的比较少，在国外欧美市场占有率比较大</li>
<li>Fedora 已经非常成熟，老师使用的就是这个</li>
<li>其他版本的来源：<ol>
<li>一部分是通过某个已成型的操作系统基础上再次演化而来</li>
<li>另一部分就是有特殊用途的，比如：Kali是专门为安全方面所开发的一个发行版，其中还有很多网络安全工具、很多黑客工具，这是一个专用的操作系统</li>
</ol>
</li>
<li>CentOS 和 Red Hat在服务器市场上占有率非常大</li>
<li>Ubuntu、Debian、Fedora在桌面系统上的占有率是比较大的</li>
</ol>
<h2 id="Linux内核官方网站"><a href="#Linux内核官方网站" class="headerlink" title="Linux内核官方网站"></a><a href="https://www.kernel.org/" target="_blank" rel="noopener">Linux内核官方网站</a></h2><ul>
<li>全世界只有这一个内核，这个内核是归Linus本人来进行维护的</li>
<li>有很多的程序员都在为这个内核贡献源代码，但是内核的主导维护者就是Linux本人</li>
</ul>
<h2 id="比较有名的Linux发行版"><a href="#比较有名的Linux发行版" class="headerlink" title="比较有名的Linux发行版"></a>比较有名的Linux发行版</h2><ol>
<li><a href="https://www.centos.org/" target="_blank" rel="noopener">CentOS</a>，由社区进行维护的，提供了三种镜像下载：<ol>
<li>DVD ISO 里面包含了图形界面的操作系统</li>
<li>Everything ISO 除了包含图形界面，还包括了所有他自己维护的软件</li>
<li>Minimal ISO 不提供图形界面，一般把mini版的IOS装到服务器上，有了图形界面反而降低了服务器的操作性能</li>
<li>是在redhat基础上重新编译和封装之后产生的CentOS，可以理解为是redhat的开源版或者是redhat的社区版，两者几乎一模一样，不同的是redhat提供了很多商业性的软件</li>
</ol>
</li>
<li><a href="https://www.redhat.com/zh" target="_blank" rel="noopener">redhat</a>，是由商业公司进行维护的和商业性的服务<ol>
<li>商业公司把Linux进行了包装，另外还提供了很多商业性的服务，所以redhat是一个商业性的操作系统</li>
<li>在官网下载比较麻烦</li>
</ol>
</li>
<li>ubuntu，在中国非常流行，还提供了一个<a href="https://www.ubuntu.com/index_kylin" target="_blank" rel="noopener">中文版的Linux ubuntu</a>的发行版</li>
</ol>
<h2 id="虚拟机（Virtual-Machine），一个虚拟的系统，安装在系统中的系统"><a href="#虚拟机（Virtual-Machine），一个虚拟的系统，安装在系统中的系统" class="headerlink" title="虚拟机（Virtual Machine），一个虚拟的系统，安装在系统中的系统"></a>虚拟机（Virtual Machine），一个虚拟的系统，安装在系统中的系统</h2><ul>
<li>指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。流行的虚拟机软件有<a href="https://www.vmware.com/cn.html" target="_blank" rel="noopener">VMware</a>、Virtual Box和Virtual PC，它们都能在Windows系统上虚拟出多个计算机。</li>
</ul>
<p>VMware/Virtual Box/Virtual PC三者的区别：</p>
<ol>
<li>VMware 商业化的，即收费的<ol>
<li>Fusion是MAC系统</li>
<li>Workstation Pro是Windows系统</li>
</ol>
</li>
<li>Virtual Box 开源的虚拟机，由Oracle进行维护</li>
<li>Virtual PC 不开源，但可以免费试用，是由微软进行维护</li>
</ol>
<h2 id="Linux与Windows的不同"><a href="#Linux与Windows的不同" class="headerlink" title="Linux与Windows的不同"></a>Linux与Windows的不同</h2><ol>
<li>Linux文件名严格区分大小写</li>
<li>Linux中所有内容以文件形式保存，包括硬件</li>
<li>Linux不靠扩展名区分文件类型<ol>
<li>根据权限区分，下面是一些约定俗成的扩展名，这些扩展名是为了管理员（即让人能够方便管理）管理文件使用的</li>
<li>压缩包：’.gz’ ‘<em>.bz2’ ‘</em>.tar.bz2’ ‘*.tgz’等</li>
<li>二进制软件包：’.rpm’</li>
<li>网页文件：’<em>.html’ ‘</em>.php’</li>
<li>脚本文件：’*.sh’</li>
<li>配置文件：’*.conf’</li>
</ol>
</li>
<li>Windows下的程序不能直接在Linux中安装和运行</li>
</ol>
<h2 id="Linux基本命令入门"><a href="#Linux基本命令入门" class="headerlink" title="Linux基本命令入门"></a>Linux基本命令入门</h2><ol>
<li>ls 显示短格式；ls -l 显示长格式</li>
<li>ls -l显示信息讲解（drwxr-xr-x+  5 liufeifei  staff   170  8 18 15:56 Public）<ol>
<li>第一栏：drwxr-xr-x+ 访问权限</li>
<li>第二栏：5 当前目录内存在文件的数量</li>
<li>第三栏和第四栏：liufeifei  staff 表示当前文件属于哪个用户和用户组</li>
<li>第五栏：170 表示当前目录或文件的大小</li>
<li>8 18 15:56 为目录或文件的创建时间</li>
<li>最后一个栏目是目录或文件的名称</li>
</ol>
</li>
<li>ls -a显示所有文件，包括隐藏文件<ol>
<li>在Linux下，只要文件名前面带有一个点就表示它是隐藏文件</li>
<li>有两个文件名比较特殊，第一个是一个点，第二个是两个点<ol>
<li>一个点：表示当前目录</li>
<li>两个点：表示的是上一级的目录</li>
</ol>
</li>
</ol>
</li>
<li>mkdir建立目录（make directories）<ol>
<li>mkdir -p [目录名]：递归创建</li>
<li>-p 是为了建立多级目录mkdir -p a/b/c，不加-p返回：No such file or directory</li>
</ol>
</li>
<li>cd切换所在目录<ol>
<li>cd [目录]（change directory）</li>
<li>cd ~ 或 cd 进入当前用户的家目录</li>
<li>cd - 进入上次目录</li>
<li>cd .. 进入上一级目录</li>
<li>cd . 进入当前目录</li>
</ol>
</li>
<li>cp复制命令（copy），公式：cp [选项] [原文件或目录] [目标目录]<ol>
<li>-r 复制目录</li>
<li>-p 连带文件属性复制</li>
<li>-d 若源文件是链接文件，则复制链接属性</li>
<li>-a 相当于 -rpd</li>
<li>复制文件 cp 就行，要是复制目录需要带 -r ，默认复制文件</li>
<li>cp -a 复制的所有隐藏属性都一样，啦啦啦，开心</li>
</ol>
</li>
<li>pwd查询所在目录位置（print working directory）</li>
<li>rmdir [目录名]删除空目录（remove empty directories）</li>
<li>rm -rf [文件或目录]（remove）<ol>
<li>-r 删除目录</li>
<li>-f 强制</li>
<li>rm -rf / 这是一条让Linux自杀的命令，会把电脑90%以上的文件删除掉，不会影响电脑的正常运行，极个别的文件删不掉</li>
</ol>
</li>
<li>mv（move）剪切或改名命令；mv [原文件或目录] [目标目录]</li>
</ol>
<h2 id="Windows命令行入门（搜索cmd查找）"><a href="#Windows命令行入门（搜索cmd查找）" class="headerlink" title="Windows命令行入门（搜索cmd查找）"></a>Windows命令行入门（搜索cmd查找）</h2><ol>
<li>查看当前目录所有文件，使用 dir</li>
<li>windows下文件夹就是目录，两者是等效的</li>
<li>切换目录，使用cd [文件夹名称]</li>
<li>创建目录 md [文件夹名称]</li>
<li>复制命令 copy [要复制的文件] [复制地点]</li>
<li>删除命令 del [删除文件名称]<ol>
<li>使用这个命令系统不会给提示，使用时候特别注意</li>
<li>使用del删除的文件不会出现在回收站当中，要多加小心</li>
</ol>
</li>
<li>改名字命令：rename [要改名字的文件名] [要改成的名字]</li>
</ol>
<h2 id="Cygwin安装和使用"><a href="#Cygwin安装和使用" class="headerlink" title="Cygwin安装和使用"></a><a href="http://www.cygwin.com/" target="_blank" rel="noopener">Cygwin</a>安装和使用</h2><ul>
<li>Cygwin是在windows平台上运行的Unix模拟环境</li>
<li>使用这个环境在windows下，来学习Linux命令</li>
<li>Cygwin是开源项目</li>
<li>安装都选默认的就可以，最后一个选择下载地址，选择最快的（即第一个），之后选择组件安装方式，选择full全部安装</li>
</ul>
<h2 id="Linux环境下补充"><a href="#Linux环境下补充" class="headerlink" title="Linux环境下补充"></a>Linux环境下补充</h2><ol>
<li>cd / 是进入系统的根目录</li>
<li>touch [文件名]新建文件，如：touch index.js</li>
<li>vi或vim [文件名]进入到对应文件中</li>
<li>cat [文件名]查看文件内容</li>
<li>ESC + :wq保存文件并退出</li>
<li>init 3 进入完全多用户模式，标准的运行级；即进入一个全命令的环境下<ol>
<li>init 0:关机 </li>
<li>init 1:单用户模式 </li>
<li>init 3:完全多用户模式，标准的运行级 </li>
<li>init 5:启动可进入X-window系统；即图形界面</li>
<li>init 6:重启</li>
</ol>
</li>
</ol>
<h2 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h2><ul>
<li>在Linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其他组的概念</li>
</ul>
<h3 id="所有者"><a href="#所有者" class="headerlink" title="所有者"></a>所有者</h3><ul>
<li>一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者</li>
<li>用ls -al命令可以看到文件的所有者</li>
<li>也可以使用chown 用户名 文件名来修改文件的所有者</li>
</ul>
<h3 id="文件所在组"><a href="#文件所在组" class="headerlink" title="文件所在组"></a>文件所在组</h3><ul>
<li>当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组</li>
<li>用ls -al命令可以看到文件的所有组</li>
<li>也可以使用chgrp 组名 文件名来修改文件所在的组</li>
</ul>
<h3 id="其他组"><a href="#其他组" class="headerlink" title="其他组"></a>其他组</h3><ul>
<li>除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组</li>
</ul>
<h2 id="文件夹权限"><a href="#文件夹权限" class="headerlink" title="文件夹权限"></a>文件夹权限</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x  15 liufeifei  admin    510 11 23 11:38 demo</span><br></pre></td></tr></table></figure>
<ol>
<li>drwxr-xr-x 10个字符确定不同用户能对文件干什么</li>
<li>第一个字符代表文件（-）、目录（d）、链接（l）</li>
<li>其余字符每3个一组（rwx）、读（r）、写（w）、执行（x）</li>
<li>第一组rwx：文件所有者的权限是读、写和执行</li>
<li>第二组r-x：与文件所有者同一组的用户的权限是读、执行但不能写</li>
<li>第三组r-x：不与文件所有者同组的其他用户的权限是读、执行但不能写</li>
<li>也可以用数字表示为：r=4 w=2 x=1，因此rwx = 4+2+1 = 7</li>
<li>15表示连接的文件数</li>
<li>liufeifei表示用户</li>
<li>admin表示用户所在的组</li>
<li>510表示文件的大小（字节）</li>
<li>11 23 11：38表示最后修改日期</li>
<li>demo表示文件名</li>
</ol>
<h2 id="改变文件夹权限"><a href="#改变文件夹权限" class="headerlink" title="改变文件夹权限"></a>改变文件夹权限</h2><p>chmod 改变文件或目录的权限<br>chmod 777 用户名（即要修改权限的文件名）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 index.js：赋予index.js权限rwxrwxrwx</span><br><span class="line">chmod 755 test.js：赋予test.js权限rwxr-xr-x</span><br></pre></td></tr></table></figure>
<p>chmod u=rwx g=rx o=rx test.js：同上u=用户权限 g=组权限 o=不同组其他用户权限<br>chmod u-x, g+w test.js：给test.js去除用户执行的权限，增加组写的权限<br>chmod a+r test.js：给所有用户添加读的权限</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/22/Linux入门基础篇/" data-id="cjbjiv6u00002rwdlvqydsquk" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CSS之BFC、IFC、FFC and GFC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/16/CSS之BFC、IFC、FFC and GFC/" class="article-date">
  <time datetime="2017-11-15T16:19:14.000Z" itemprop="datePublished">2017-11-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/16/CSS之BFC、IFC、FFC and GFC/">CSS之BFC、IFC、FFC and GFC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="CSS之BFC、IFC、FFC-and-GFC"><a href="#CSS之BFC、IFC、FFC-and-GFC" class="headerlink" title="CSS之BFC、IFC、FFC and GFC"></a>CSS之BFC、IFC、FFC and GFC</h1><p>[TOC]</p>
<h2 id="什么是FC？"><a href="#什么是FC？" class="headerlink" title="什么是FC？"></a>什么是FC？</h2><ul>
<li>FC的全称是：Formatting Contexts，是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</li>
</ul>
<h2 id="BFC-Block-Formatting-Contexts"><a href="#BFC-Block-Formatting-Contexts" class="headerlink" title="BFC(Block Formatting Contexts)"></a>BFC(Block Formatting Contexts)</h2><ul>
<li>意为“块级格式化上下文”。就是页面上的一个渲染区域，容器内的子元素不会对外面的元素布局产生影响，反之亦然。</li>
</ul>
<h3 id="BFC的布局规则"><a href="#BFC的布局规则" class="headerlink" title="BFC的布局规则:"></a>BFC的布局规则:</h3><ol>
<li>内部的盒子会在垂直方向，一个个地放置</li>
<li>盒子垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的上下margin会发生重叠</li>
<li>每个元素的左边，与包含的盒子的左边相接触，即使存在浮动也是如此</li>
<li>BFC的区域不会与float重叠</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此</li>
<li>计算BFC的高度时，浮动元素也参与计算</li>
</ol>
<h3 id="如何生成BFC："><a href="#如何生成BFC：" class="headerlink" title="如何生成BFC："></a>如何生成BFC：</h3><ol>
<li>根元素或其它包含它的元素</li>
<li>float的值不为none</li>
<li>overflow的值不为visible</li>
<li>position的值不为relative和static</li>
<li>display的值为table-cell,table-caption和inline-block中的任何一个</li>
</ol>
<ul>
<li>一个块格式化上下文包括创建它的元素内部所有内容，除了被包含于创建新的块级格式化上下文的后代元素内的元素。</li>
<li>块格式化上下文对于定位与清除浮动很重要。定位和清除浮动的样式规则只适用于处于同一块格式化上下文内的元素。浮动不会影响其它块格式化上下文中元素的布局，并且清除浮动只能清除同一块格式化上下文中在它前面的元素的浮动。</li>
</ul>
<h2 id="IFC-Inline-Formatting-Contexts"><a href="#IFC-Inline-Formatting-Contexts" class="headerlink" title="IFC(Inline Formatting Contexts)"></a>IFC(Inline Formatting Contexts)</h2><ul>
<li>意为“内联格式化上下文”,IFC中，盒子依次水平放置，从包含块的顶部开始</li>
</ul>
<h2 id="FFC-Flex-Formatting-Contexts"><a href="#FFC-Flex-Formatting-Contexts" class="headerlink" title="FFC(Flex Formatting Contexts)"></a>FFC(Flex Formatting Contexts)</h2><ul>
<li>意为“自适应格式化上下文”,display值为flex或者inline-flex的元素将会生成自适应容器。flex box由伸缩容器和伸缩子元素组成。通过设置元素display:flex/inline-flex可以得到伸缩容器，前者为块级元素，后者为行内元素。伸缩容器外元素不受影响。</li>
</ul>
<h2 id="GFC-GridLayout-Formatting-Contexts"><a href="#GFC-GridLayout-Formatting-Contexts" class="headerlink" title="GFC(GridLayout Formatting Contexts)"></a>GFC(GridLayout Formatting Contexts)</h2><ul>
<li>意为“网格布局格式化上下文”当一个元素设置为display:grid的时候，此元素将获得一个独立的渲染区域，可以在网格容器上定义网格行和列，为每一个网格定义位置和空间。GFC和table的区别在于GridLayout会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染。 </li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/16/CSS之BFC、IFC、FFC and GFC/" data-id="cjbjiv6tt0000rwdlpy1n4fgs" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/12/23/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2017/12/23/抓包工具介绍/">抓包工具介绍</a>
          </li>
        
          <li>
            <a href="/2017/12/11/Homebrew-macOS缺失的软件包管理器（简称brew）/">Homebrew-macOS缺失的软件包管理器（简称brew）</a>
          </li>
        
          <li>
            <a href="/2017/12/07/SEO从理论到实践/">SEO从理论到实践</a>
          </li>
        
          <li>
            <a href="/2017/12/06/音标学习记录-国际音标/">音标学习记录-国际音标</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>