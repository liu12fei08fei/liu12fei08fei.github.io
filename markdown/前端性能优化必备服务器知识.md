# 前端性能优化必备服务器知识

[TOC]

## 性能优化的本质

* 前端优化不是说，代码写的效率有多高，玩一些编码上的技巧，实际的优化不是这样的；这种只是代码层面的优化
* 代码层面的优化是有限的，实际我们需要在这个项目周期中的各个环节进行优化
* 找到周期内，各个环节中的性能瓶颈，把瓶颈消除掉，是整体性的优化，这才是真正的性能优化
* 源代码上的优化实际上是算法上的优化

## 成本

* n个合作伙伴完成一件事情的成本是n+1或者更多
* 因为有沟通成本在里面，即使一个人做事情，也是有沟通成本的
* 自己和自己商量怎么做更好

## 浏览器加载顺序，处理HTML的整个过程

* 浏览器实现标准
* 处理流程

![浏览器加载顺序](http://p1fg8xetu.bkt.clouddn.com/浏览器加载顺序.png)

### 参数说明

* navigationStart 加载起始时间
* redirectStart 重定向开始时间（如果发生了HTTP重定向，每次重定向都和当前文档同域的话，就返回开始重定向的fetchStart的值。其他情况，则返回0）
* redirectEnd 重定向结束时间（如果发生了HTTP重定向，每次重定向都和当前文档同域的话，就返回最后一次重定向接受完数据的时间。其他情况则返回0）
* fetchStart 浏览器发起资源请求时，如果有缓存，则返回读取缓存的开始时间
* domainLookupStart 查询DNS的开始时间。如果请求没有发起DNS请求，如keep-alive，缓存等，则返回fetchStart
* domainLookupEnd 查询DNS的结束时间。如果没有发起DNS请求，同上 
* connectStart 开始建立TCP请求的时间。如果请求是keep-alive，缓存等，则返回domainLookupEnd
* (secureConnectionStart) 如果在进行TLS或SSL，则返回握手时间，安全连接
* connectEnd 完成TCP链接的时间。如果是keep-alive，缓存等，同connectStart
* requestStart 发起请求的时间
* responseStart 服务器开始响应的时间

### 模块说明

**prompt for unload 提示卸载**

* 处理之前页面的流程

**redirect 重定向**

* 从这开始处理新页面的流程
* 处理缓存和跳转，进行本地跳转，不是服务器端跳转

**app cache 应用程序缓存**

* 处理本地缓存，本地有缓存，取本地缓存，没有缓存，直接跳过

*unload 卸载*

> 把前面页面中，缓存在内存中的数据，清除掉
> 同时，把页面中已经显示的页面数据清除掉

**dns DNS**

> 这里的DNS是本地路由器，路由器实际是负责DNS中转
> 真正的DNS服务器，是存在运营商端，运营商会把DNS服务器地址发过来

* 本地没有缓存，需要请求服务器资源
* 进行域名解析，拿到服务器真实ip

**tcp TCP**

* 拿到服务器ip，网络传输层，开始工作
* 先建立TCP连接，只有建立了TCP连接，HTTP才能工作

*TCP and HTTP relation*

> TCP是路
> HTTP是车
> 没有路，没法发车

**request 请求**

* HTTP开始发车
* 向服务器发出请求

**response 响应**

* 服务器返回响应

**processing 处理**

* 处理请求过来的资源=>html/css/js/image/video/audio...
* 请求回来的数据，是已二进制的形式存储在内存中
* 需要把二进制数据进行处理，处理成适当的格式
* processing主要是处理HTML的，即DOM树解析和渲染

*dom loading DOM加载*

> 开始解析dom文档
> 开始解析并渲染dom树
> 格式化成dom树

*dom interactive DOM交互*

> dom树解析完毕
> html本身就是文本文件，只不过内部承载了信息

*dom content loaded DOM加载的内容*

> 处理dom树，是CPU+内存协同完成
> 通过流水线的形式，进行工作
> 处理完成放在内存指定的位置中

*dom complete DOM完成*

> 整个DOM操作完成，走下生产线

*load event start 负载的启*
*load event end Load事件结束*

> 进行页面渲染
> 浏览器通过unload先处理，整个浏览器环境
> 然后在触发开发人员自己书写的unload事件
> 然后交给显存里面，显卡把显存里面的信息拿出来，进行渲染

#### CSS渲染是在unload之后

* 也就是HTML解析完成之后

#### JS修改HTML结构，是重新触发Processing过程

* 只是改变html文档的部分内容

## DNS详解

### DNS介绍

* DNS是Domain Name System，域名系统，用于将域名转换为IP
* 本质就是数据的映射，处理关联关系，即key => value
* 域名=>more IP，即一个域名对应多个IP

### 顶级域名

* 域名级别是网址分类的一个标准，包括顶级域名、二级域名等。
* 一个完整的域名由二个或二个以上部分组成，各部分之间用英文的句号"."来分隔，倒数第一个"."的右边部分称为顶级域名（TLD，也称为一级域名，包含一个合法字符串，和一个域名后缀），顶级域名的左边部分字符串到下个"."为止称为二级域名（SLD），二级域名的左边部分称为三级域名，以此类推，每一级的域名控制它下一级域名的分配。

### 域名资源记录

* 域名后面对应的是什么
* 资源服务

### 域名服务器

* 域名和IP对应关系，保存在服务器上
* 接收域名转换服务的机器，即：域名服务器
* 域名服务器，内容包括：域名和IP对应的数据库、实现DNS通信协议的程序（DNS服务程序）

### 域名解析

* 是一个动作
* 我们发送域名，域名服务器返回指定IP，这个过程叫做域名解析

**DNS服务器**

* 树形结构
* 具有等级：全世界共有13台根域名服务器

**根域名服务器**

* 根服务器主要用来管理互联网的主目录，全世界只有13台（这13台根域名服务器名字分别为“A”至“M”），1个为主根服务器在美国。其余12个均为辅根服务器，其中9个在美国，欧洲2个，位于英国和瑞典，亚洲1个位于日本。

## TCP三次握手≈

**为什么要挥手（为什么要断开链路）？**

* 因为服务器维持连接要消耗系统资源（内存、CPU...）
* 数据传输：带宽数据(实际我们要传输的数据)+带外数据(维持这个链路的其他数据，是一种损耗，由计算机处理，即：费电、损耗硬件)

**TCP和UDP**

* TCP是要创建稳定的链路，即：打电话
* UDP只管传输，至于到没到不知道，即网络，好比-用喇叭通知

**s三次握手是什么？**

* TCP在进行连接的时候的一种连接机制
* 目的：是为了建立一个稳定的链路
* 怎么建立一个稳定的链路？

**为什么三次握手？**

* 从流程上证明，必须经过三次交互才能确定，两边形成了稳定的链路（数学上进行了证明）
* 消息传输是畅通的，无论是发出消息还是返回消息，都能够正常的接收
* 第一次是客户端发起请求，SYN seq=x，发送数据包
* 传输的数据顺序不一定是我们传输的顺序，原因是我们不知道数据走的是哪个路由器
* 所以需要传输顺序号，接收端通过顺序号，把接收到的信息进行组装，seq=x
* 还有应答号，ack=x+1、服务器返回自己的顺序号seq=y

**为什么会不稳定？**

* 原因是，传输层后面具有，网络层、数据链路层、物理层
* TCP错误会直接返回到HTTP层

**例子**

```
“喂，你听得到吗？”
“我听得到呀，你听得到我吗？”
“我能听到你，今天balabala……”
```

## TCP四次挥手-断开TCP连接

* 一般是客户端主动发起断开请求
* 服务器也可以主动断开，只有一件事情发生，即：超时
* 或者说服务器认为客户端有问题，做了非法操作
* 在正常的流程中，一般是客户端主动发起断开请求
* 开始发送断开请求包，服务器收到请求包的时候，需要给出应答
* 服务器会再发送一条确认数据，客户端进行确认传输

**为什么不能三次挥手？**

* 因为数据传输是双向的
* 客户端确认没有数据发送
* 服务器也要确认自己是否还有数据进行传输

**为什么服务器连续发送两次，而不是发送一次包？**

* 因为服务器要检查自己的状态
* 为了减少响应时间，分开发送

**查看浏览器和服务器之间有多少个路由**

```
// linux and mac
traceroute www.baidu.com

// windows
tracert www.baidu.com
```

* 把经过的路由ip全部展示出来
* 星号(*)表示隐藏的路由器

**tcpdump**

* 用来抓包的
* 安装`yum install tcpdump`
* `tcpdump -i eth0 tcp`

> `-i`接口
> 监听物理网卡所有的包，tcp的包

* `tcpdump -i eth0 host 61.135.169.121`
* 监听百度的连接

> `61.135.169.121`是通过`ping www.baidu.com`

**ifconfig**

* `eth0`物理网卡
* `lo`本地环路地址，虚拟网卡

**curl**

* 命令行请求网站

## CDN与集群

### CDN

* 是一种分布式的方案

**传统的方案，就是服务器就是一台**

* 服务器压力过大
* 客户端可能在不同的地理位置(跨越的路由过多)、不同的网络里面(运营商的网)
* 会导致请求反应很慢
* CDN就是用来加速的
* 可以使用市场上的CDN服务，只需要简单的配置即可

> 为了解决这些问题，采用多台服务器，都是镜像服务器
> 目的就是追求最快的响应
> CDN非常复杂，有专门的上市公司做这块

### 云服务

* 不是CDN，是分布式的一种应用

