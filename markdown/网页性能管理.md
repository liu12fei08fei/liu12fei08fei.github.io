# 网页性能管理

[TOC]

## 网页生成的过程

1. HTML代码转化成DOM
2. CSS代码转化成CSSOM（CSS Object Model）
3. 结合DOM和CSSOM，生成一颗渲染树（包含每个节点的视觉信息）
4. 生成布局（layout），即将所有渲染树的所有节点进行平面合成
5. 将布局绘制（point）在屏幕上

* 第一步到第三步都非常快，耗时的是第四步和第五步
* “生成布局”（flow）和“绘制”（paint）这两步，合称为“渲染”

## 重排和重绘

**重排**

* 当DOM的变化影响了元素的集合属性（宽和高），浏览器需要重新计算元素的几何属性，同样其他元素的集合属性和位置也会因此受到影响。
* 浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树

**重绘**

* 完成重排后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为“重绘”

## 重排何时发生

> 页面布局和几何属性改变时就需要“重排”

1. 添加或删除可见的DOM元素
2. 元素位置改变
3. 元素尺寸改变（包括：外边距、内边距、边框厚度、宽度、高度等属性改变）
4. 内容改变，例如：文本改变或图片被另一个不同尺寸的图片替代
5. 页面渲染器初始化
6. 浏览器窗口尺寸改变

### 疑问排查

**CSS3和JS操作DOM，两者动画哪个更好？**

* CSS虽然是由浏览器实现，按理在浏览器支持的前提下性能会更好，然而使用者如果加入了其他干扰，发生频繁的重绘或者回流，自然性能就差了。
* [从原理和根源优化JS，使得JS动画优于CSS动画](http://zencode.in/19.CSS-vs-JS%E5%8A%A8%E7%94%BB%EF%BC%9A%E8%B0%81%E6%9B%B4%E5%BF%AB%EF%BC%9F.html)
* 所以完全说哪个好，问题本身就有问题，看问题还得看其本质

## 渲染树变化的排队与刷新

> 每次重排都会产生大量的计算消耗，浏览器通过队列化修改并批量执行来优化重排过程
> 平时开发，很可能会（经常不知不觉）强制刷新队列并要求计划任务立即执行
> 获取布局信息的操作会导致队列刷新

**触发重排，刷新队列的属性和方法**

```
offsetTop，offsetLeft，offsetWidth，offsetHeight
scrollTop，scrollLeft，scrollWidth，scrollHeight
clientTop，clientLeft，clientWidth，clientHeight
getComputedStyle()（currentStyle in ID）
```

**不要在布局信息改变时查询它**

```
var oBox = document.querySelector('.box'),
	bg;

// 修改同一属性低效的方式
oBox.style.color = 'red';
bg = oBox.style.backgroundColor;
oBox.style.color = 'pink';
bg = oBox.style.backgroundImage;
oBox.style.color = 'purple';
bg = oBox.style.backgroundColor;
```

* 示例，body元素的前景色被修改了三次，每次修改后都读取一个oBox的样式，导致浏览器需要刷新队列并重排
* 更有效率的方法是不要在布局信息改变时查询它

```
var oBox = document.querySelector('.box'),
	bg;

// 优化后大代码
oBox.style.color = 'red';
oBox.style.color = 'pink';
oBox.style.color = 'purple';
bg = oBox.style.backgroundColor;
bg = oBox.style.backgroundImage;
bg = oBox.style.backgroundColor;
```

## 提高性能的技巧

1. DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。
2. 如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。
3. 不要一条条地改变样式，而要通过改变class，或者csstext属性，一次性地改变样式。
4. 尽量使用离线DOM，而不是真实的网面DOM，来改变元素样式。比如，操作Document Fragment对象，完成后再把这个对象加入DOM。再比如，使用 cloneNode() 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点
5. 先将元素设为`display: none`（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。
6. position属性为absolute或fixed的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。
7. 只在必要的时候，才将元素的display属性为可见，因为不可见的元素不影响重排和重绘。另外，`visibility:hidden`的元素只对重绘有影响，不影响重排。
8. 使用虚拟DOM的脚本库，比如React、Vue等。
9. 使用 window.requestAnimationFrame()、window.requestIdleCallback() 这两个方法调节重新渲染
10. 使用事件委托来减少事件处理器的数量

## 刷新率

> 很多时候，密集的重新渲染是无法避免的，比如scroll事件的回调函数和网页动画。
> 网页动画的每一帧（frame）都是一次重新渲染。
> 每秒低于24帧的动画，人眼就能感受到停顿。
> 一般的网页动画，需要达到每秒30帧到60帧的频率，才能比较流畅。
> 如果能达到每秒70帧甚至80帧，就会极其流畅。

* 大多数显示器的刷新频率是60Hz，为了与系统一致，以及节省电力，浏览器会自动按照这个频率，刷新动画（如果可以做到的话）。
* 这意味着，一秒之内进行60次重新渲染，每次重新渲染的时间不能超过16.66毫秒。
* 一秒之间能够完成多少次重新渲染，这个指标就被称为**"刷新率"**，英文为FPS（frame per second）。60次重新渲染，就是60FPS。

*如果想达到60帧的刷新率，就意味着JavaScript线程每个任务的耗时，必须少于16毫秒。一个解决办法是使用Web Worker，主线程只用于UI渲染，然后跟UI渲染不相干的任务，都放在Worker线程。*

## 开发者工具的Timeline面板

> Chrome浏览器开发者工具的Timeline面板，是查看"刷新率"的最佳工具

## window.requestAnimationFrame()

> 有一些JavaScript方法可以调节重新渲染，大幅提高网页性能
> 最重要的，就是 window.requestAnimationFrame() 方法。它可以将某些代码放到下一次重新渲染时执行。

## window.requestIdleCallback()

> 函数window.requestIdleCallback()，也可以用来调节重新渲染
> 它指定只有当一帧的末尾有空闲时间，才会执行回调函数。


