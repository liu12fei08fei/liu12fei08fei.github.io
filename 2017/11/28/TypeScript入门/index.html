<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>TypeScript入门 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="TypeScript入门[TOC]  微软开发一门编程语言 JavaScript的超集 遵循ES6脚本语言规范   TypeScript扩展了JavaScript的语法，任何已经存在的JS程序，可以不加任何改动的在TypeScript环境下运行 TypeScript只是向JS中添加一些新的，遵循ES6规范的语法，以及基于类的面向对象编程的这种特性 其次，2016年9月底发布的Angular2框架，">
<meta property="og:type" content="article">
<meta property="og:title" content="TypeScript入门">
<meta property="og:url" content="http://yoursite.com/2017/11/28/TypeScript入门/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="TypeScript入门[TOC]  微软开发一门编程语言 JavaScript的超集 遵循ES6脚本语言规范   TypeScript扩展了JavaScript的语法，任何已经存在的JS程序，可以不加任何改动的在TypeScript环境下运行 TypeScript只是向JS中添加一些新的，遵循ES6规范的语法，以及基于类的面向对象编程的这种特性 其次，2016年9月底发布的Angular2框架，">
<meta property="og:updated_time" content="2017-12-23T15:48:37.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TypeScript入门">
<meta name="twitter:description" content="TypeScript入门[TOC]  微软开发一门编程语言 JavaScript的超集 遵循ES6脚本语言规范   TypeScript扩展了JavaScript的语法，任何已经存在的JS程序，可以不加任何改动的在TypeScript环境下运行 TypeScript只是向JS中添加一些新的，遵循ES6规范的语法，以及基于类的面向对象编程的这种特性 其次，2016年9月底发布的Angular2框架，">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-TypeScript入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/28/TypeScript入门/" class="article-date">
  <time datetime="2017-11-27T16:58:24.000Z" itemprop="datePublished">2017-11-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      TypeScript入门
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="TypeScript入门"><a href="#TypeScript入门" class="headerlink" title="TypeScript入门"></a>TypeScript入门</h1><p>[TOC]</p>
<ol>
<li>微软开发一门编程语言</li>
<li>JavaScript的超集</li>
<li>遵循ES6脚本语言规范</li>
</ol>
<ul>
<li>TypeScript扩展了JavaScript的语法，任何已经存在的JS程序，可以不加任何改动的在TypeScript环境下运行</li>
<li>TypeScript只是向JS中添加一些新的，遵循ES6规范的语法，以及基于类的面向对象编程的这种特性</li>
<li>其次，2016年9月底发布的Angular2框架，这个框架本身是由TypeScript语言本身来编写的</li>
<li>TypeScript这门语言是由Microsoft（微软）和Google（谷歌），在背后支持</li>
<li>因此，TypeScript有可能称为前端脚本语言发展的一个主流方向</li>
</ul>
<h2 id="课程内容介绍"><a href="#课程内容介绍" class="headerlink" title="课程内容介绍"></a>课程内容介绍</h2><ol>
<li>学习TypeScript的好处</li>
<li>安装TypeScript开发环境</li>
<li>TypeScript概念、语法和特性介绍</li>
</ol>
<h2 id="课程介绍-前置知识"><a href="#课程介绍-前置知识" class="headerlink" title="课程介绍-前置知识"></a>课程介绍-前置知识</h2><ol>
<li>理解ES5、ES6、JavaScript、TypeScript的概念和关系<ol>
<li>ES是客户端脚本语言的规范，ES5、ES6是不同的版本</li>
<li>JavaScript和TypeScript是两种客户端脚本语言</li>
<li>JavaScript是实现了ES5规范，TypeScript实现了ES6规范</li>
</ol>
</li>
<li>有基础的JavaScript开发经验</li>
</ol>
<h2 id="TypeScript的优势"><a href="#TypeScript的优势" class="headerlink" title="TypeScript的优势"></a>TypeScript的优势</h2><ol>
<li>支持ES6规范</li>
<li>强大的IDE支持</li>
<li>Angular2的开发语言</li>
</ol>
<h2 id="搭建TypeScript开发环境"><a href="#搭建TypeScript开发环境" class="headerlink" title="搭建TypeScript开发环境"></a>搭建TypeScript开发环境</h2><ul>
<li>就是安装TypeScript compiler</li>
</ul>
<h3 id="什么是compiler？为什么需要compiler？"><a href="#什么是compiler？为什么需要compiler？" class="headerlink" title="什么是compiler？为什么需要compiler？"></a>什么是compiler？为什么需要compiler？</h3><ol>
<li>它是编译器，编译器的作用就是把TypeScript代码转化成JS代码</li>
<li>因为主流浏览器没有完全支持ES6，需要转化成ES5</li>
</ol>
<h3 id="使用在线compiler开发"><a href="#使用在线compiler开发" class="headerlink" title="使用在线compiler开发"></a><a href="http://www.typescriptlang.org/play/index.html" target="_blank" rel="noopener">使用在线compiler开发</a></h3><h3 id="搭建本地TypeScript开发环境"><a href="#搭建本地TypeScript开发环境" class="headerlink" title="搭建本地TypeScript开发环境"></a>搭建本地TypeScript开发环境</h3><h2 id="TypeScript-字符串新特性（所有例子都是es6语法）"><a href="#TypeScript-字符串新特性（所有例子都是es6语法）" class="headerlink" title="TypeScript-字符串新特性（所有例子都是es6语法）"></a>TypeScript-字符串新特性（所有例子都是es6语法）</h2><p>一、 多行字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = `111,</span><br><span class="line">222,</span><br><span class="line">333,</span><br><span class="line">444`;</span><br></pre></td></tr></table></figure>
<ul>
<li>多行字符串使用双撇号声明变量（即：反引号），好处是可以随意换行无需拼接字符串</li>
</ul>
<p>二、 字符串模板：在多行字符串里，用一个表达式去插入变量或者用以调用方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var myName = &apos;怪诞咖啡&apos;;</span><br><span class="line"></span><br><span class="line">var getName = function () &#123;</span><br><span class="line">    return myName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(`Hello $&#123;myName&#125;`); // 调用变量</span><br><span class="line">console.log(`Hello $&#123;getName()&#125;`); // 调用函数</span><br></pre></td></tr></table></figure>
<ul>
<li>注：字符串模板<code>${}</code>，只有在反引号``中有作用，在双引号（””）和单引号（’’）中只会当字符串输出</li>
</ul>
<p>三、 自动拆分字符串：当用一个字符串模板去调用一个方法的时候，这个字符串模板里面表达式的值会自动赋值给被调用方法中的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function test(name, age, job) &#123;</span><br><span class="line">    console.log(name);</span><br><span class="line">    console.log(age);</span><br><span class="line">    console.log(job);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var myName = &quot;怪诞咖啡&quot;;</span><br><span class="line">var getAge = function () &#123;</span><br><span class="line">    return 18;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test`Hello my name is $&#123;myName&#125;, I&apos;m $&#123;getAge()&#125;`;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用test函数，进行参数传递时候，不需要写双括号，直接使用反引号</li>
<li>第一个参数是：字符串模板的值 =&gt; [“Hello my name is “,”, I’m “,””]</li>
<li>第二个参数是：第一个表达式的值 =&gt; 怪诞咖啡</li>
<li>第三个参数是：第二个表达式的值 =&gt; 18</li>
</ul>
<h2 id="TypeScript-参数新特性"><a href="#TypeScript-参数新特性" class="headerlink" title="TypeScript-参数新特性"></a>TypeScript-参数新特性</h2><h3 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h3><p>一、 在参数名称后面使用冒号来指定参数的类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var myName: string = &apos;怪诞咖啡&apos;;</span><br><span class="line"></span><br><span class="line">myName = 13;</span><br></pre></td></tr></table></figure>
<ul>
<li>注：报错只会在typescript环境下，在编译后的es5环境下是不会报错的</li>
</ul>
<p>二、 类型推断机制，就是当第一次给变量赋值，此变量的类型就固定为第一次赋值的类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var myName = &apos;怪诞咖啡&apos;;</span><br><span class="line"></span><br><span class="line">myName = 13;</span><br></pre></td></tr></table></figure>
<ul>
<li>注：报错只会在typescript环境下，在编译后的es5环境下是不会报错的</li>
</ul>
<p>三、 要想在typescript环境下任意赋值，就需要赋值为:any</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var myName:any = &apos;怪诞咖啡&apos;;</span><br><span class="line"></span><br><span class="line">myName = 13;</span><br></pre></td></tr></table></figure>
<p>四、 其他基本类型</p>
<ol>
<li>数值类型 var num: number = 20;</li>
<li>布尔类型 var boo: boolean = true;</li>
<li>void类型：void不是用来声明变量的，而是用来声明变量的返回值的</li>
</ol>
<p>void类型例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function test(): void&#123;</span><br><span class="line">    return &apos;&apos;; // 报错</span><br><span class="line">&#125;</span><br><span class="line">function test(): string&#123;</span><br><span class="line">    return &apos;&apos;; // 不报错</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>五、 除了给变量和函数声明类型外，还可以给参数声明类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function test(name: string, age) &#123;</span><br><span class="line">    return name;</span><br><span class="line">&#125;</span><br><span class="line">test(1); // 报错，只能使用string类型进行调用</span><br></pre></td></tr></table></figure>
<p><strong>注：介绍了如何声明类型、typescript类型推断机制、五种基本的类型、可以声明类型的位置</strong></p>
<p>六、 自定义类型：在typescript里面，可以通过class或接口来申明自定义类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var feifei: Person = new Person();</span><br><span class="line">feifei.name = &apos;怪诞咖啡&apos;;</span><br><span class="line">feifei.age = 18;</span><br></pre></td></tr></table></figure>
<ul>
<li>当我们写feifei.的时候会提示Person有name和age两个属性</li>
</ul>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>在参数声明后面用等号来指定参数的默认值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test(a: string, b: string, c: string) &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(b);</span><br><span class="line">    console.log(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(&apos;1&apos;,&apos;2&apos;,&apos;3&apos;); // 必须传递三个string类型的参数，否则提示错误</span><br></pre></td></tr></table></figure>
<p>给参数指定默认值之后，可以不传递参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test(a: string, b: string, c: string=&apos;攻城狮&apos;) &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(b);</span><br><span class="line">    console.log(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(&apos;1&apos;, &apos;2&apos;); // 只传递两个参数，第三个参数使用默认值</span><br></pre></td></tr></table></figure>
<ul>
<li>默认值的设定应该遵循从右向左一次设定，否则无法起到合理的作用</li>
</ul>
<h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>在方法的参数声明后面用问号来标明此参数为可选参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test(a: string, b?: string, c: string=&apos;攻城狮&apos;) &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(b);</span><br><span class="line">    console.log(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(&apos;1&apos;); // 只传递一个参数，第二个参数为undefined，第三个参数为默认值</span><br></pre></td></tr></table></figure>
<p>注意几点：</p>
<ul>
<li>b设置为可选参数，要处理可选参数没传的情况</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test(a: string, b?: string, c: string=&apos;攻城狮&apos;) &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(b.length);</span><br><span class="line">    console.log(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：b参数为可选参数，在不传递参数值的情况下是不允许调用undefined的length属性的</p>
<ul>
<li>和默认值一样，可选参数不能声明在必选参数的后面的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test(a?: string, b: string, c: string=&apos;攻城狮&apos;) &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(b);</span><br><span class="line">    console.log(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：我给a设置为可选参数，b为必选参数，会直接报错；和设置默认值是一样的，不允许在必选参数前面设置默认值</p>
<h2 id="函数新特性"><a href="#函数新特性" class="headerlink" title="函数新特性"></a>函数新特性</h2><h3 id="Rest-and-Spread操作符（…）：用来声明任意数量的方法参数，即rest参数"><a href="#Rest-and-Spread操作符（…）：用来声明任意数量的方法参数，即rest参数" class="headerlink" title="Rest and Spread操作符（…）：用来声明任意数量的方法参数，即rest参数"></a>Rest and Spread操作符（…）：用来声明任意数量的方法参数，即rest参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function fun(...args) &#123;</span><br><span class="line">    args.forEach(function (arg) &#123; </span><br><span class="line">        console.log(arg);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun(1, 2, 3);</span><br><span class="line">console.log(&apos;******&apos;); // 分隔符</span><br><span class="line">fun(10,8,18,49,100,7)</span><br></pre></td></tr></table></figure>
<p><strong>一个Rest and Spread操作符，反方向使用的方法–目前版本2.6不支持</strong></p>
<ul>
<li>设置传递固定数量的参数，在使用的时候传递不定数量的参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function fun(a, b, c) &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(b);</span><br><span class="line">    console.log(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var args = [1, 2];</span><br><span class="line">fun(...args); // 在typescript中报错，在转化的es5中支持，返回值为：1 2 undefined</span><br><span class="line"></span><br><span class="line">console.log(&apos;*****&apos;);</span><br><span class="line"></span><br><span class="line">var args2 = [7, 8, 9, 10, 12];</span><br><span class="line">fun(...args2); // 在typescript中报错，在转化的es5中支持，返回值为：7 8 9</span><br></pre></td></tr></table></figure>
<h3 id="generator函数：控制函数的执行过程，手工暂停和恢复代码执行"><a href="#generator函数：控制函数的执行过程，手工暂停和恢复代码执行" class="headerlink" title="generator函数：控制函数的执行过程，手工暂停和恢复代码执行"></a>generator函数：控制函数的执行过程，手工暂停和恢复代码执行</h3><ol>
<li>在es5中，调用一个方法的时候，没有办法在函数执行到一半的时候，进行暂停执行</li>
<li>在es6中，新加一个关键字yield，这个关键字可以实现方法暂停执行；yield就好像给代码加上了断点一样，可以通过编程的手段，控制代码走到某个点暂停执行，然后调用特定方法的时候在进行，可以往复循环</li>
</ol>
<p>声明一个generator函数，只要在function后面添加一个<em>即可：`function</em> fun(){}`</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function* fun()&#123;</span><br><span class="line">  console.log(&apos;start&apos;);</span><br><span class="line">  </span><br><span class="line">  yield;</span><br><span class="line">  </span><br><span class="line">  console.log(&apos;finish&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// fun(); // 这样调用generator是不起作用的，必须使用下面的方式调用</span><br><span class="line"></span><br><span class="line">var fn = fun();</span><br><span class="line">fn.next(); // 打印start</span><br><span class="line"></span><br><span class="line">fn.next(); // 打印finish</span><br></pre></td></tr></table></figure>
<h3 id="destructuring析构表达式：通过表达式将对象或数组拆解成任意数量的变量"><a href="#destructuring析构表达式：通过表达式将对象或数组拆解成任意数量的变量" class="headerlink" title="destructuring析构表达式：通过表达式将对象或数组拆解成任意数量的变量"></a>destructuring析构表达式：通过表达式将对象或数组拆解成任意数量的变量</h3><ul>
<li>从对象中通过析构表达式获得相应属性和方法，对象析构是用<code>{}</code>大括号声明</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    myName: &apos;怪诞咖啡&apos;,</span><br><span class="line">    age: &#123;</span><br><span class="line">      age1: 18,</span><br><span class="line">      age2:80</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var &#123; myName, age: &#123; age1, age2 &#125; &#125; = a(); // 析构表达式，包括嵌套属性</span><br><span class="line"></span><br><span class="line">var &#123; myName:newName, age: &#123; age1, age2 &#125; &#125; = a(); // 析构表达式，给myName起一个新的名字newName</span><br><span class="line"></span><br><span class="line">console.log(age1);</span><br><span class="line">console.log(age2);</span><br></pre></td></tr></table></figure>
<p>解析：返回值，即<code>return</code>返回值，的结构和我们的析构表达式的结构<code>{ myName, age: { age1, age2 } }</code>一一对应，所以析构表达式，即可理解为，解析结构获得对象属性的方法</p>
<ul>
<li>从数组中通过析构表达式获得相应属性和方法，数组析构是用<code>[]</code>方括号声明</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4];</span><br><span class="line">var [num1, num2, ...other] = arr; // 获取第一个和第二个，其余变量赋值给other</span><br><span class="line">var [,,num3,num4] = arr; // 获取第三和第四个值</span><br></pre></td></tr></table></figure>
<p>析构表达式好处：当你需要从一个对象的属性或者是数组的元素里面，用其中的值赋值给其余变量的时候，可以让我们写更少的代码</p>
<h2 id="表达式和循环"><a href="#表达式和循环" class="headerlink" title="表达式和循环"></a>表达式和循环</h2><h3 id="箭头表达式：用来声明匿名函数，消除传统匿名函数的this指针问题"><a href="#箭头表达式：用来声明匿名函数，消除传统匿名函数的this指针问题" class="headerlink" title="箭头表达式：用来声明匿名函数，消除传统匿名函数的this指针问题"></a>箭头表达式：用来声明匿名函数，消除传统匿名函数的this指针问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 无参数表达式</span><br><span class="line">var sum = () =&gt; &#123;&#125;</span><br><span class="line">// 只有一个参数的表达式</span><br><span class="line">var sum = arg =&gt; &#123;&#125;</span><br><span class="line">// 单行表达式</span><br><span class="line">var sum = (arg1, arg2) =&gt; arg1 + arg2;</span><br><span class="line">// 多行表达式</span><br><span class="line">var sum2 = (arg1, arg2) =&gt; &#123;</span><br><span class="line">  return arg1 + arg2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5];</span><br><span class="line">var flt = arr.filter(val =&gt; val % 2 == 0);</span><br><span class="line">console.log(flt);</span><br></pre></td></tr></table></figure>
<p>箭头函数的优势：</p>
<ol>
<li>简化书写</li>
<li>最大的优势，消除了js里，this关键字的问题</li>
</ol>
<ul>
<li>this指向问题</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function fn(myName: string) &#123;</span><br><span class="line">  this.myName = myName;</span><br><span class="line"></span><br><span class="line">  setInterval(function () &#123;</span><br><span class="line">    console.log(&apos;myName is：&apos;+this.myName);</span><br><span class="line">  &#125;,1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var myName = 1; // 全局myName，后面的this指向了全局，而不是a</span><br><span class="line">var a = new fn(&apos;怪诞咖啡&apos;);</span><br></pre></td></tr></table></figure>
<ul>
<li>改用箭头函数，消除this指向问题</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function fn(myName: string) &#123;</span><br><span class="line">  this.myName = myName;</span><br><span class="line"></span><br><span class="line">  setInterval(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;myName is：&apos;+this.myName);</span><br><span class="line">  &#125;,1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var myName = 1;</span><br><span class="line">var a = new fn(&apos;怪诞咖啡&apos;); // 消除指向问题</span><br></pre></td></tr></table></figure>
<h3 id="forEach-、for-in和for-of"><a href="#forEach-、for-in和for-of" class="headerlink" title="forEach()、for in和for of"></a>forEach()、for in和for of</h3><h4 id="forEach："><a href="#forEach：" class="headerlink" title="forEach："></a>forEach：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4];</span><br><span class="line">arr.desc = &apos;I am number type!&apos;; // 这行在typescript里面会报错</span><br><span class="line"></span><br><span class="line">arr.forEach(val =&gt; console.log(val));</span><br></pre></td></tr></table></figure>
<p>问题：</p>
<ol>
<li>forEach会把desc属性忽略掉</li>
<li>foeEach里面无法打断循环，break不支持</li>
</ol>
<h4 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [11, 22, 33, 44];</span><br><span class="line">arr.desc = &apos;I am number type!&apos;;</span><br><span class="line"></span><br><span class="line">for (var item in arr) &#123;</span><br><span class="line">  console.log(item); // key=&gt; 1,2,3,4,desc</span><br><span class="line">  console.log(arr[item]); //value=&gt;11,22,33,44,I am number type! </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题：</p>
<ul>
<li>不光把数组里面的值循环出来，同样会把定义的属性也循环出来；结果很可能不是我们希望的样子</li>
</ul>
<h4 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h4><ol>
<li>和forEach差不错，循环的是你对象或数组的值，而不是像for in循环的key</li>
<li>for of和forEach的差别是，可以用break可以打断循环</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [11, 22, 33, 44];</span><br><span class="line">arr.desc = &apos;I am number type!&apos;;</span><br><span class="line"></span><br><span class="line">for (var item of arr) &#123;</span><br><span class="line">  console.log(item); // key=&gt; 11,22,33,44 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面向对象特性"><a href="#面向对象特性" class="headerlink" title="面向对象特性"></a>面向对象特性</h2><h3 id="类（class）：TypeScript的核心，使用TypeScript开发时，大部分代码都是写在类里面的。"><a href="#类（class）：TypeScript的核心，使用TypeScript开发时，大部分代码都是写在类里面的。" class="headerlink" title="类（class）：TypeScript的核心，使用TypeScript开发时，大部分代码都是写在类里面的。"></a>类（class）：TypeScript的核心，使用TypeScript开发时，大部分代码都是写在类里面的。</h3><ul>
<li>这里会介绍类的定义，构造函数，以及类的继承</li>
</ul>
<h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h4><ul>
<li>使用class关键字声明类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以指定类的属性和方法，一个完整的类具有属性和方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  name;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    console.log(&apos;I am eating!&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>实例化：可以把类理解成为一个模子；所谓实例化，就是根据模子做出实际的产品出来</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  name;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    console.log(&apos;I am eating!&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 = new Person();</span><br><span class="line">p1.name = &apos;Hello&apos;;</span><br><span class="line">p1.eat();</span><br><span class="line"></span><br><span class="line">var p2 = new Person();</span><br><span class="line">p2.name = &apos;World&apos;;</span><br><span class="line">p2.eat();</span><br></pre></td></tr></table></figure>
<h4 id="返回控制符"><a href="#返回控制符" class="headerlink" title="返回控制符"></a>返回控制符</h4><ul>
<li>在声明类的属性和方法的时候，可以为其指定一个返回控制符</li>
<li>返回控制符的作用是控制类的属性和方法是否可以在外部被访问到</li>
<li>返回控制符有三个：<ol>
<li>public共用，默认public</li>
<li>private私有，只有在类的内部才能被访问到，在外部访问不到</li>
<li>protected受保护的，可以在类的内部和子类（继承）里面可以被访问到，在外部访问不到</li>
</ol>
</li>
</ul>
<h4 id="类的构造函数，即：constructor方法"><a href="#类的构造函数，即：constructor方法" class="headerlink" title="类的构造函数，即：constructor方法"></a>类的构造函数，即：constructor方法</h4><ul>
<li>实际上是类里面一个特殊的方法，这个方法只有在类被实例化的时候才会被调用</li>
<li>而且只会调用一次</li>
<li>外部无法访问到constructor构造函数的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    console.log(&apos;构造函数&apos;)</span><br><span class="line">  &#125;;</span><br><span class="line">  name=&apos;默认值&apos;;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    console.log(&apos;I am eating!&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 = new Person();</span><br><span class="line">p1.name = &apos;Hello&apos;;</span><br><span class="line">p1.eat();</span><br><span class="line"></span><br><span class="line">var p2 = new Person();</span><br><span class="line">p2.name = &apos;World&apos;;</span><br><span class="line">p2.eat();</span><br></pre></td></tr></table></figure>
<p>构造函数的作用：可以在实例化的时候，指定相应属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  constructor(public name:string) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  eat() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 = new Person(&apos;Hello&apos;);</span><br><span class="line">p1.eat();</span><br><span class="line"></span><br><span class="line">var p2 = new Person(&apos;World&apos;);</span><br><span class="line">p2.eat();</span><br></pre></td></tr></table></figure>
<p>注意：构造函数里面，定义属性，要使用控制符来明确声明，即：<code>public name:any</code>；如果是<code>name:any</code>这样，说明没有声明该属性，下面无法访问到</p>
<h4 id="类的继承：两个关键字"><a href="#类的继承：两个关键字" class="headerlink" title="类的继承：两个关键字"></a>类的继承：两个关键字</h4><ol>
<li>一个是extends，用来声明类的继承关系</li>
<li>另一个是super，用来调用父类的构造函数和方法</li>
</ol>
<h5 id="extends，获得继承类中所有属性和方法"><a href="#extends，获得继承类中所有属性和方法" class="headerlink" title="extends，获得继承类中所有属性和方法"></a>extends，获得继承类中所有属性和方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  constructor(public name:string) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  eat() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Employee extends Person&#123;</span><br><span class="line">  // 定义新的属性和方法</span><br><span class="line">  code: string;</span><br><span class="line"></span><br><span class="line">  work() &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let em = new Employee(&apos;coffee&apos;);</span><br><span class="line">em.eat();</span><br></pre></td></tr></table></figure>
<h5 id="super"><a href="#super" class="headerlink" title="super"></a>super</h5><h6 id="调用父类的构造函数"><a href="#调用父类的构造函数" class="headerlink" title="调用父类的构造函数"></a>调用父类的构造函数</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  constructor(public name:string) &#123;</span><br><span class="line">    console.log(&apos;父类构造函数&apos;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  eat() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Employee extends Person&#123;</span><br><span class="line"></span><br><span class="line">  constructor(name: string, code: string) &#123; </span><br><span class="line">    // 必须调用父类的构造函数，这是硬性规定</span><br><span class="line">    super(name);</span><br><span class="line">    console.log(&apos;子类构造函数&apos;);</span><br><span class="line">    this.code = code;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  code: string;</span><br><span class="line"></span><br><span class="line">  work() &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let em = new Employee(&apos;coffee&apos;,&apos;8&apos;);</span><br><span class="line">em.eat();</span><br></pre></td></tr></table></figure>
<h6 id="用来调用父类的方法"><a href="#用来调用父类的方法" class="headerlink" title="用来调用父类的方法"></a>用来调用父类的方法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  constructor(public name:string) &#123;</span><br><span class="line">    console.log(&apos;父类构造函数&apos;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  eat() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Employee extends Person&#123;</span><br><span class="line"></span><br><span class="line">  constructor(name: string, code: string) &#123; </span><br><span class="line">    // 必须调用父类的构造函数，这是硬性规定</span><br><span class="line">    super(name);</span><br><span class="line">    console.log(&apos;子类构造函数&apos;);</span><br><span class="line">    this.code = code;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  code: string;</span><br><span class="line"></span><br><span class="line">  work() &#123;</span><br><span class="line">    // 调用父类的方法</span><br><span class="line">    super.eat();</span><br><span class="line">  &#125;;</span><br><span class="line">  // 返回控制符</span><br><span class="line">  private doWork() &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let em = new Employee(&apos;coffee&apos;,&apos;8&apos;);</span><br><span class="line">em.work();</span><br></pre></td></tr></table></figure>
<h3 id="面向对象特性-1"><a href="#面向对象特性-1" class="headerlink" title="面向对象特性"></a>面向对象特性</h3><h4 id="泛型-generic：是指参数化的类型，一般用来限制集合的内容"><a href="#泛型-generic：是指参数化的类型，一般用来限制集合的内容" class="headerlink" title="泛型-generic：是指参数化的类型，一般用来限制集合的内容"></a>泛型-generic：是指参数化的类型，一般用来限制集合的内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  constructor(public name:string) &#123;</span><br><span class="line">    console.log(&apos;父类构造函数&apos;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  eat() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Employee extends Person&#123;</span><br><span class="line"></span><br><span class="line">  constructor(name: string, code: string) &#123; </span><br><span class="line">    // 必须调用父类的构造函数，这是硬性规定</span><br><span class="line">    super(name);</span><br><span class="line">    console.log(&apos;子类构造函数&apos;);</span><br><span class="line">    this.code = code;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  code: string;</span><br><span class="line"></span><br><span class="line">  work() &#123;</span><br><span class="line">    // 调用父类的方法</span><br><span class="line">    super.eat();</span><br><span class="line">  &#125;;</span><br><span class="line">  private doWork() &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var workers: Array&lt;Person&gt; = [];</span><br><span class="line">workers[0] = new Person(&apos;神经了&apos;);</span><br><span class="line">workers[1] = new Employee(&apos;神经了&apos;, &apos;8&apos;);</span><br><span class="line">workers[2] = 3; // 报错，指定放Person类型的数据</span><br></pre></td></tr></table></figure>
<h4 id="接口-Interface：用来建立某种代码约定，使得其它开发者在调用某个方法或创建新的类时必须遵循接口所定义的代码约定"><a href="#接口-Interface：用来建立某种代码约定，使得其它开发者在调用某个方法或创建新的类时必须遵循接口所定义的代码约定" class="headerlink" title="接口-Interface：用来建立某种代码约定，使得其它开发者在调用某个方法或创建新的类时必须遵循接口所定义的代码约定"></a>接口-Interface：用来建立某种代码约定，使得其它开发者在调用某个方法或创建新的类时必须遵循接口所定义的代码约定</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface IPerson&#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">  constructor(public config:IPerson)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 声明属性</span><br><span class="line">var p1 = new Person(&#123;</span><br><span class="line">  name: &apos;coffee&apos;,</span><br><span class="line">  age:8</span><br><span class="line">&#125;);</span><br><span class="line">console.log(p1);</span><br></pre></td></tr></table></figure>
<p>实现对应的接口中的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface Animal&#123;</span><br><span class="line">  eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Sheep implements Animal&#123;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    console.log(&apos;I eat grass&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Tiger implements Animal&#123;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    console.log(&apos;I eat meat&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模块-module：模块可以帮助开发者将代码分割为可重用的单元。开发者可以自己决定将模块中的哪些资源（类、方法、变量）暴露出去供外部使用，哪些资源只在模块内使用。"><a href="#模块-module：模块可以帮助开发者将代码分割为可重用的单元。开发者可以自己决定将模块中的哪些资源（类、方法、变量）暴露出去供外部使用，哪些资源只在模块内使用。" class="headerlink" title="模块-module：模块可以帮助开发者将代码分割为可重用的单元。开发者可以自己决定将模块中的哪些资源（类、方法、变量）暴露出去供外部使用，哪些资源只在模块内使用。"></a>模块-module：模块可以帮助开发者将代码分割为可重用的单元。开发者可以自己决定将模块中的哪些资源（类、方法、变量）暴露出去供外部使用，哪些资源只在模块内使用。</h4><ol>
<li>模块在typescript里面就是一个文件，一个文件就是一个模块</li>
<li>在模块内部有两个关键字来支撑模块的特性，export暴露接口、import</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 文件a</span><br><span class="line">import &#123;newName&#125; from &quot;./b&quot;; // 引入b文件，使用b文件中提供的接口newName</span><br><span class="line"></span><br><span class="line">// a文件对外提供接口</span><br><span class="line">export var prop1;</span><br><span class="line">var prop2;</span><br><span class="line">export function func1()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">function func2()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export class Class1&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Class2&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 获得b文件提供的接口</span><br><span class="line">console.log(newName);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// b文件</span><br><span class="line">import &#123;Class1, func1, prop1&#125; from &quot;./a&quot;; // 引入a文件</span><br><span class="line">// 获取a文件提供的接口</span><br><span class="line">console.log(prop1);</span><br><span class="line"></span><br><span class="line">func1();</span><br><span class="line"></span><br><span class="line">new Class1&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 对外提供接口</span><br><span class="line">export var newName;</span><br></pre></td></tr></table></figure>
<h4 id="注解-annotation：注解为程序的元素（类、方法、变量）加上更直观更明了的说明，这些说明信息与程序的业务逻辑无关，而是供指定的工具或框架使用的"><a href="#注解-annotation：注解为程序的元素（类、方法、变量）加上更直观更明了的说明，这些说明信息与程序的业务逻辑无关，而是供指定的工具或框架使用的" class="headerlink" title="注解-annotation：注解为程序的元素（类、方法、变量）加上更直观更明了的说明，这些说明信息与程序的业务逻辑无关，而是供指定的工具或框架使用的"></a>注解-annotation：注解为程序的元素（类、方法、变量）加上更直观更明了的说明，这些说明信息与程序的业务逻辑无关，而是供指定的工具或框架使用的</h4><h4 id="类型定义文件（-d-ts）：类型定义文件用来帮助开发者在TypeScript中使用已有的JS的工具包；如：jQuery、zepto等"><a href="#类型定义文件（-d-ts）：类型定义文件用来帮助开发者在TypeScript中使用已有的JS的工具包；如：jQuery、zepto等" class="headerlink" title="类型定义文件（*.d.ts）：类型定义文件用来帮助开发者在TypeScript中使用已有的JS的工具包；如：jQuery、zepto等"></a>类型定义文件（*.d.ts）：类型定义文件用来帮助开发者在TypeScript中使用已有的JS的工具包；如：jQuery、zepto等</h4><p>如何找到类型定义文件，肯定不能自己一个个的写；使用tyings来快速启动</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/28/TypeScript入门/" data-id="cjbjiv6u20004rwdlhd2mp46q" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/11/30/github个人博客绑定单独阿里域名指南/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          github个人博客绑定单独阿里域名指南
        
      </div>
    </a>
  
  
    <a href="/2017/11/25/搜索引擎命令大全！/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">搜索引擎命令大全！</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/12/23/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2017/12/23/抓包工具介绍/">抓包工具介绍</a>
          </li>
        
          <li>
            <a href="/2017/12/11/Homebrew-macOS缺失的软件包管理器（简称brew）/">Homebrew-macOS缺失的软件包管理器（简称brew）</a>
          </li>
        
          <li>
            <a href="/2017/12/07/SEO从理论到实践/">SEO从理论到实践</a>
          </li>
        
          <li>
            <a href="/2017/12/06/音标学习记录-国际音标/">音标学习记录-国际音标</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>